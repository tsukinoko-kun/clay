// Code generated by "go tool cxgo"; DO NOT EDIT.

package clay

import (
	"math"
	"unsafe"

	"github.com/gotranspile/cxgo/runtime/libc"
)

const (
	__NULL     = 0
	__MAXFLOAT = 3.4028234663852886e+38
)

var __ELEMENT_DEFINITION_LATCH uint8

func __SuppressUnusedLatchDefinitionVariableWarning() {
	_ = __ELEMENT_DEFINITION_LATCH
}

type String struct {
	IsStaticallyAllocated bool
	Length                int32
	Chars                 *byte
}
type StringSlice struct {
	Length    int32
	Chars     *byte
	BaseChars *byte
}
type Context struct {
	maxElementCount                    int32
	maxMeasureTextCacheWordCount       int32
	warningsEnabled                    bool
	errorHandler                       ErrorHandler
	booleanWarnings                    BooleanWarnings
	warnings                           __WarningArray
	pointerInfo                        PointerData
	layoutDimensions                   Dimensions
	dynamicElementIndexBaseHash        ElementId
	dynamicElementIndex                uint32
	debugModeEnabled                   bool
	disableCulling                     bool
	externalScrollHandlingEnabled      bool
	debugSelectedElementId             uint32
	generation                         uint32
	arenaResetOffset                   uint64
	measureTextUserData                any
	queryScrollOffsetUserData          any
	internalArena                      Arena
	layoutElements                     LayoutElementArray
	renderCommands                     RenderCommandArray
	openLayoutElementStack             __int32_tArray
	layoutElementChildren              __int32_tArray
	layoutElementChildrenBuffer        __int32_tArray
	textElementData                    __TextElementDataArray
	AspectRatioElementIndexes          __int32_tArray
	reusableElementIndexBuffer         __int32_tArray
	layoutElementClipElementIds        __int32_tArray
	layoutConfigs                      __LayoutConfigArray
	elementConfigs                     __ElementConfigArray
	textElementConfigs                 __TextElementConfigArray
	AspectRatioElementConfigs          __AspectRatioElementConfigArray
	imageElementConfigs                __ImageElementConfigArray
	floatingElementConfigs             __FloatingElementConfigArray
	ClipElementConfigs                 __ClipElementConfigArray
	customElementConfigs               __CustomElementConfigArray
	borderElementConfigs               __BorderElementConfigArray
	sharedElementConfigs               __SharedElementConfigArray
	layoutElementIdStrings             __StringArray
	wrappedTextLines                   __WrappedTextLineArray
	layoutElementTreeNodeArray1        __LayoutElementTreeNodeArray
	layoutElementTreeRoots             __LayoutElementTreeRootArray
	layoutElementsHashMapInternal      __LayoutElementHashMapItemArray
	layoutElementsHashMap              __int32_tArray
	measureTextHashMapInternal         __MeasureTextCacheItemArray
	measureTextHashMapInternalFreeList __int32_tArray
	measureTextHashMap                 __int32_tArray
	measuredWords                      __MeasuredWordArray
	measuredWordsFreeList              __int32_tArray
	openClipElementStack               __int32_tArray
	pointerOverIds                     ElementIdArray
	scrollContainerDatas               __ScrollContainerDataInternalArray
	treeNodeVisited                    __boolArray
	dynamicStringData                  __charArray
	debugElementData                   __DebugElementDataArray
}
type Arena struct {
	NextAllocation uint64
	Capacity       uint64
	Memory         *byte
}
type Dimensions struct {
	Width  float32
	Height float32
}
type Vector2 struct {
	X float32
	Y float32
}
type Color struct {
	R float32
	G float32
	B float32
	A float32
}
type BoundingBox struct {
	X      float32
	Y      float32
	Width  float32
	Height float32
}
type ElementId struct {
	Id       uint32
	Offset   uint32
	BaseId   uint32
	StringId String
}
type ElementIdArray struct {
	Capacity      int32
	Length        int32
	InternalArray *ElementId
}
type CornerRadius struct {
	TopLeft     float32
	TopRight    float32
	BottomLeft  float32
	BottomRight float32
}
type LayoutDirection int32

const (
	LEFT_TO_RIGHT = LayoutDirection(iota)
	TOP_TO_BOTTOM
)

type LayoutAlignmentX int32

const (
	ALIGN_X_LEFT = LayoutAlignmentX(iota)
	ALIGN_X_RIGHT
	ALIGN_X_CENTER
)

type LayoutAlignmentY int32

const (
	ALIGN_Y_TOP = LayoutAlignmentY(iota)
	ALIGN_Y_BOTTOM
	ALIGN_Y_CENTER
)

type __SizingType int32

const (
	__SIZING_TYPE_FIT = __SizingType(iota)
	__SIZING_TYPE_GROW
	__SIZING_TYPE_PERCENT
	__SIZING_TYPE_FIXED
)

type ChildAlignment struct {
	X LayoutAlignmentX
	Y LayoutAlignmentY
}
type SizingMinMax struct {
	Min float32
	Max float32
}
type SizingAxis struct {
	Size struct {
		// union
		MinMax  SizingMinMax
		Percent float32
	}
	Type __SizingType
}
type Sizing struct {
	Width  SizingAxis
	Height SizingAxis
}
type Padding struct {
	Left   uint16
	Right  uint16
	Top    uint16
	Bottom uint16
}
type __PaddingWrapper struct {
	Wrapped Padding
}
type LayoutConfig struct {
	Sizing          Sizing
	Padding         Padding
	ChildGap        uint16
	ChildAlignment  ChildAlignment
	LayoutDirection LayoutDirection
}
type __LayoutConfigWrapper struct {
	Wrapped LayoutConfig
}
type TextElementConfigWrapMode int32

const (
	TEXT_WRAP_WORDS = TextElementConfigWrapMode(iota)
	TEXT_WRAP_NEWLINES
	TEXT_WRAP_NONE
)

type TextAlignment int32

const (
	TEXT_ALIGN_LEFT = TextAlignment(iota)
	TEXT_ALIGN_CENTER
	TEXT_ALIGN_RIGHT
)

type TextElementConfig struct {
	UserData      any
	TextColor     Color
	FontId        uint16
	FontSize      uint16
	LetterSpacing uint16
	LineHeight    uint16
	WrapMode      TextElementConfigWrapMode
	TextAlignment TextAlignment
}
type __TextElementConfigWrapper struct {
	Wrapped TextElementConfig
}
type AspectRatioElementConfig struct {
	AspectRatio float32
}
type __AspectRatioElementConfigWrapper struct {
	Wrapped AspectRatioElementConfig
}
type ImageElementConfig struct {
	ImageData any
}
type __ImageElementConfigWrapper struct {
	Wrapped ImageElementConfig
}
type FloatingAttachPointType int32

const (
	ATTACH_POINT_LEFT_TOP = FloatingAttachPointType(iota)
	ATTACH_POINT_LEFT_CENTER
	ATTACH_POINT_LEFT_BOTTOM
	ATTACH_POINT_CENTER_TOP
	ATTACH_POINT_CENTER_CENTER
	ATTACH_POINT_CENTER_BOTTOM
	ATTACH_POINT_RIGHT_TOP
	ATTACH_POINT_RIGHT_CENTER
	ATTACH_POINT_RIGHT_BOTTOM
)

type FloatingAttachPoints struct {
	Element FloatingAttachPointType
	Parent  FloatingAttachPointType
}
type PointerCaptureMode int32

const (
	POINTER_CAPTURE_MODE_CAPTURE = PointerCaptureMode(iota)
	POINTER_CAPTURE_MODE_PASSTHROUGH
)

type FloatingAttachToElement int32

const (
	ATTACH_TO_NONE = FloatingAttachToElement(iota)
	ATTACH_TO_PARENT
	ATTACH_TO_ELEMENT_WITH_ID
	ATTACH_TO_ROOT
)

type FloatingClipToElement int32

const (
	CLIP_TO_NONE = FloatingClipToElement(iota)
	CLIP_TO_ATTACHED_PARENT
)

type FloatingElementConfig struct {
	Offset             Vector2
	Expand             Dimensions
	ParentId           uint32
	ZIndex             int16
	AttachPoints       FloatingAttachPoints
	PointerCaptureMode PointerCaptureMode
	AttachTo           FloatingAttachToElement
	ClipTo             FloatingClipToElement
}
type __FloatingElementConfigWrapper struct {
	Wrapped FloatingElementConfig
}
type CustomElementConfig struct {
	CustomData any
}
type __CustomElementConfigWrapper struct {
	Wrapped CustomElementConfig
}
type ClipElementConfig struct {
	Horizontal  bool
	Vertical    bool
	ChildOffset Vector2
}
type __ClipElementConfigWrapper struct {
	Wrapped ClipElementConfig
}
type BorderWidth struct {
	Left            uint16
	Right           uint16
	Top             uint16
	Bottom          uint16
	BetweenChildren uint16
}
type BorderElementConfig struct {
	Color Color
	Width BorderWidth
}
type __BorderElementConfigWrapper struct {
	Wrapped BorderElementConfig
}
type TextRenderData struct {
	StringContents StringSlice
	TextColor      Color
	FontId         uint16
	FontSize       uint16
	LetterSpacing  uint16
	LineHeight     uint16
}
type RectangleRenderData struct {
	BackgroundColor Color
	CornerRadius    CornerRadius
}
type ImageRenderData struct {
	BackgroundColor Color
	CornerRadius    CornerRadius
	ImageData       any
}
type CustomRenderData struct {
	BackgroundColor Color
	CornerRadius    CornerRadius
	CustomData      any
}
type ScrollRenderData struct {
	Horizontal bool
	Vertical   bool
}
type (
	ClipRenderData   ScrollRenderData
	BorderRenderData struct {
		Color        Color
		CornerRadius CornerRadius
		Width        BorderWidth
	}
)
type RenderData struct {
	// union
	Rectangle RectangleRenderData
	Text      TextRenderData
	Image     ImageRenderData
	Custom    CustomRenderData
	Border    BorderRenderData
	Clip      ClipRenderData
}
type ScrollContainerData struct {
	ScrollPosition            *Vector2
	ScrollContainerDimensions Dimensions
	ContentDimensions         Dimensions
	Config                    ClipElementConfig
	Found                     bool
}
type ElementData struct {
	BoundingBox BoundingBox
	Found       bool
}
type RenderCommandType int32

const (
	RENDER_COMMAND_TYPE_NONE = RenderCommandType(iota)
	RENDER_COMMAND_TYPE_RECTANGLE
	RENDER_COMMAND_TYPE_BORDER
	RENDER_COMMAND_TYPE_TEXT
	RENDER_COMMAND_TYPE_IMAGE
	RENDER_COMMAND_TYPE_SCISSOR_START
	RENDER_COMMAND_TYPE_SCISSOR_END
	RENDER_COMMAND_TYPE_CUSTOM
)

type RenderCommand struct {
	BoundingBox BoundingBox
	RenderData  RenderData
	UserData    any
	Id          uint32
	ZIndex      int16
	CommandType RenderCommandType
}
type RenderCommandArray struct {
	Capacity      int32
	Length        int32
	InternalArray *RenderCommand
}
type PointerDataInteractionState int32

const (
	POINTER_DATA_PRESSED_THIS_FRAME = PointerDataInteractionState(iota)
	POINTER_DATA_PRESSED
	POINTER_DATA_RELEASED_THIS_FRAME
	POINTER_DATA_RELEASED
)

type PointerData struct {
	Position Vector2
	State    PointerDataInteractionState
}
type ElementDeclaration struct {
	Layout          LayoutConfig
	BackgroundColor Color
	CornerRadius    CornerRadius
	AspectRatio     AspectRatioElementConfig
	Image           ImageElementConfig
	Floating        FloatingElementConfig
	Custom          CustomElementConfig
	Clip            ClipElementConfig
	Border          BorderElementConfig
	UserData        any
}
type __ElementDeclarationWrapper struct {
	Wrapped ElementDeclaration
}
type ErrorType int32

const (
	ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED = ErrorType(iota)
	ERROR_TYPE_ARENA_CAPACITY_EXCEEDED
	ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED
	ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED
	ERROR_TYPE_DUPLICATE_ID
	ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND
	ERROR_TYPE_PERCENTAGE_OVER_1
	ERROR_TYPE_INTERNAL_ERROR
	ERROR_TYPE_UNBALANCED_OPEN_CLOSE
)

type ErrorData struct {
	ErrorType ErrorType
	ErrorText String
	UserData  any
}
type ErrorHandler struct {
	ErrorHandlerFunction func(errorText ErrorData)
	UserData             any
}

var (
	LAYOUT_DEFAULT                        LayoutConfig = LayoutConfig{}
	__Color_DEFAULT                       Color        = Color{}
	__CornerRadius_DEFAULT                CornerRadius = CornerRadius{}
	__BorderWidth_DEFAULT                 BorderWidth  = BorderWidth{}
	__currentContext                      *Context
	__defaultMaxElementCount              int32 = 8192
	__defaultMaxMeasureTextWordCacheCount int32 = 16384
)

func __ErrorHandlerFunctionDefault(errorText ErrorData) {
	_ = errorText
}

var (
	__SPACECHAR      String = String{Length: 1, Chars: libc.CString(" ")}
	__STRING_DEFAULT String = String{}
)

type BooleanWarnings struct {
	MaxElementsExceeded           bool
	MaxRenderCommandsExceeded     bool
	MaxTextMeasureCacheExceeded   bool
	TextMeasurementFunctionNotSet bool
}
type __Warning struct {
	BaseMessage    String
	DynamicMessage String
}

var __WARNING_DEFAULT __Warning = __Warning{}

type __WarningArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__Warning
}
type SharedElementConfig struct {
	BackgroundColor Color
	CornerRadius    CornerRadius
	UserData        any
}
type __SharedElementConfigWrapper struct {
	Wrapped SharedElementConfig
}
type __boolArray struct {
	Capacity      int32
	Length        int32
	InternalArray *bool
}
type __boolArraySlice struct {
	Length        int32
	InternalArray *bool
}

var _Bool_DEFAULT bool = false

func __boolArray_Allocate_Arena(capacity int32, arena *Arena) __boolArray {
	return __boolArray{Capacity: capacity, Length: 0, InternalArray: (*bool)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(bool(false))), arena))}
}

func __boolArray_Get(array *__boolArray, index int32) *bool {
	if __Array_RangeCheck(index, array.Length) {
		return (*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), index))
	}
	return &_Bool_DEFAULT
}

func __boolArray_GetValue(array *__boolArray, index int32) bool {
	if __Array_RangeCheck(index, array.Length) {
		return *(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), index))
	}
	return _Bool_DEFAULT
}

func __boolArray_Add(array *__boolArray, item bool) *bool {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}())) = item
		return (*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), array.Length-1))
	}
	return &_Bool_DEFAULT
}

func __boolArraySlice_Get(slice *__boolArraySlice, index int32) *bool {
	if __Array_RangeCheck(index, slice.Length) {
		return (*bool)(unsafe.Add(unsafe.Pointer(slice.InternalArray), index))
	}
	return &_Bool_DEFAULT
}

func __boolArray_RemoveSwapback(array *__boolArray, index int32) bool {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed bool = *(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), index))
		*(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)) = *(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), array.Length))
		return removed
	}
	return _Bool_DEFAULT
}

func __boolArray_Set(array *__boolArray, index int32, value bool) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*bool)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __int32_tArray struct {
	Capacity      int32
	Length        int32
	InternalArray *int32
}
type __int32_tArraySlice struct {
	Length        int32
	InternalArray *int32
}

var int32_t_DEFAULT int32 = 0

func __int32_tArray_Allocate_Arena(capacity int32, arena *Arena) __int32_tArray {
	return __int32_tArray{Capacity: capacity, Length: 0, InternalArray: (*int32)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(int32(0))), arena))}
}

func __int32_tArray_Get(array *__int32_tArray, index int32) *int32 {
	if __Array_RangeCheck(index, array.Length) {
		return (*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index)))
	}
	return &int32_t_DEFAULT
}

func __int32_tArray_GetValue(array *__int32_tArray, index int32) int32 {
	if __Array_RangeCheck(index, array.Length) {
		return *(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index)))
	}
	return int32_t_DEFAULT
}

func __int32_tArray_Add(array *__int32_tArray, item int32) *int32 {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(array.Length-1)))
	}
	return &int32_t_DEFAULT
}

func __int32_tArraySlice_Get(slice *__int32_tArraySlice, index int32) *int32 {
	if __Array_RangeCheck(index, slice.Length) {
		return (*int32)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index)))
	}
	return &int32_t_DEFAULT
}

func __int32_tArray_RemoveSwapback(array *__int32_tArray, index int32) int32 {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed int32 = *(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index)))
		*(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index))) = *(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(array.Length)))
		return removed
	}
	return int32_t_DEFAULT
}

func __int32_tArray_Set(array *__int32_tArray, index int32, value int32) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*int32)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(int32(0))*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __charArray struct {
	Capacity      int32
	Length        int32
	InternalArray *byte
}
type __charArraySlice struct {
	Length        int32
	InternalArray *byte
}

var char_DEFAULT int8 = 0

func __charArray_Allocate_Arena(capacity int32, arena *Arena) __charArray {
	return __charArray{Capacity: capacity, Length: 0, InternalArray: (*byte)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(int8(0))), arena))}
}

func __charArray_Get(array *__charArray, index int32) *byte {
	if __Array_RangeCheck(index, array.Length) {
		return (*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), index))
	}
	return (*byte)(unsafe.Pointer(&char_DEFAULT))
}

func __charArray_GetValue(array *__charArray, index int32) int8 {
	if __Array_RangeCheck(index, array.Length) {
		return int8(*(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)))
	}
	return char_DEFAULT
}

func __charArray_Add(array *__charArray, item int8) *byte {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}())) = byte(item)
		return (*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), array.Length-1))
	}
	return (*byte)(unsafe.Pointer(&char_DEFAULT))
}

func __charArraySlice_Get(slice *__charArraySlice, index int32) *byte {
	if __Array_RangeCheck(index, slice.Length) {
		return (*byte)(unsafe.Add(unsafe.Pointer(slice.InternalArray), index))
	}
	return (*byte)(unsafe.Pointer(&char_DEFAULT))
}

func __charArray_RemoveSwapback(array *__charArray, index int32) int8 {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed int8 = int8(*(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)))
		*(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)) = *(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), array.Length))
		return removed
	}
	return char_DEFAULT
}

func __charArray_Set(array *__charArray, index int32, value int8) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*byte)(unsafe.Add(unsafe.Pointer(array.InternalArray), index)) = byte(value)
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type ElementIdArraySlice struct {
	Length        int32
	InternalArray *ElementId
}

var ElementId_DEFAULT ElementId = ElementId{}

func ElementIdArray_Allocate_Arena(capacity int32, arena *Arena) ElementIdArray {
	return ElementIdArray{Capacity: capacity, Length: 0, InternalArray: (*ElementId)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(ElementId{})), arena))}
}

func ElementIdArray_Get(array *ElementIdArray, index int32) *ElementId {
	if __Array_RangeCheck(index, array.Length) {
		return (*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index)))
	}
	return &ElementId_DEFAULT
}

func ElementIdArray_GetValue(array *ElementIdArray, index int32) ElementId {
	if __Array_RangeCheck(index, array.Length) {
		return *(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index)))
	}
	return ElementId_DEFAULT
}

func ElementIdArray_Add(array *ElementIdArray, item ElementId) *ElementId {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(array.Length-1)))
	}
	return &ElementId_DEFAULT
}

func ElementIdArraySlice_Get(slice *ElementIdArraySlice, index int32) *ElementId {
	if __Array_RangeCheck(index, slice.Length) {
		return (*ElementId)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index)))
	}
	return &ElementId_DEFAULT
}

func ElementIdArray_RemoveSwapback(array *ElementIdArray, index int32) ElementId {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed ElementId = *(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index)))
		*(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index))) = *(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(array.Length)))
		return removed
	}
	return ElementId_DEFAULT
}

func ElementIdArray_Set(array *ElementIdArray, index int32, value ElementId) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*ElementId)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementId{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __LayoutConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *LayoutConfig
}
type __LayoutConfigArraySlice struct {
	Length        int32
	InternalArray *LayoutConfig
}

var LayoutConfig_DEFAULT LayoutConfig = LayoutConfig{}

func __LayoutConfigArray_Allocate_Arena(capacity int32, arena *Arena) __LayoutConfigArray {
	return __LayoutConfigArray{Capacity: capacity, Length: 0, InternalArray: (*LayoutConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(LayoutConfig{})), arena))}
}

func __LayoutConfigArray_Get(array *__LayoutConfigArray, index int32) *LayoutConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index)))
	}
	return &LayoutConfig_DEFAULT
}

func __LayoutConfigArray_GetValue(array *__LayoutConfigArray, index int32) LayoutConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index)))
	}
	return LayoutConfig_DEFAULT
}

func __LayoutConfigArray_Add(array *__LayoutConfigArray, item LayoutConfig) *LayoutConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(array.Length-1)))
	}
	return &LayoutConfig_DEFAULT
}

func __LayoutConfigArraySlice_Get(slice *__LayoutConfigArraySlice, index int32) *LayoutConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*LayoutConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index)))
	}
	return &LayoutConfig_DEFAULT
}

func __LayoutConfigArray_RemoveSwapback(array *__LayoutConfigArray, index int32) LayoutConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed LayoutConfig = *(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index)))
		*(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index))) = *(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(array.Length)))
		return removed
	}
	return LayoutConfig_DEFAULT
}

func __LayoutConfigArray_Set(array *__LayoutConfigArray, index int32, value LayoutConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*LayoutConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __TextElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *TextElementConfig
}
type __TextElementConfigArraySlice struct {
	Length        int32
	InternalArray *TextElementConfig
}

var TextElementConfig_DEFAULT TextElementConfig = TextElementConfig{}

func __TextElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __TextElementConfigArray {
	return __TextElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*TextElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(TextElementConfig{})), arena))}
}

func __TextElementConfigArray_Get(array *__TextElementConfigArray, index int32) *TextElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index)))
	}
	return &TextElementConfig_DEFAULT
}

func __TextElementConfigArray_GetValue(array *__TextElementConfigArray, index int32) TextElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index)))
	}
	return TextElementConfig_DEFAULT
}

func __TextElementConfigArray_Add(array *__TextElementConfigArray, item TextElementConfig) *TextElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(array.Length-1)))
	}
	return &TextElementConfig_DEFAULT
}

func __TextElementConfigArraySlice_Get(slice *__TextElementConfigArraySlice, index int32) *TextElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*TextElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index)))
	}
	return &TextElementConfig_DEFAULT
}

func __TextElementConfigArray_RemoveSwapback(array *__TextElementConfigArray, index int32) TextElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed TextElementConfig = *(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index)))
		*(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index))) = *(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return TextElementConfig_DEFAULT
}

func __TextElementConfigArray_Set(array *__TextElementConfigArray, index int32, value TextElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*TextElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(TextElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __AspectRatioElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *AspectRatioElementConfig
}
type __AspectRatioElementConfigArraySlice struct {
	Length        int32
	InternalArray *AspectRatioElementConfig
}

var AspectRatioElementConfig_DEFAULT AspectRatioElementConfig = AspectRatioElementConfig{}

func __AspectRatioElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __AspectRatioElementConfigArray {
	return __AspectRatioElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*AspectRatioElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(AspectRatioElementConfig{})), arena))}
}

func __AspectRatioElementConfigArray_Get(array *__AspectRatioElementConfigArray, index int32) *AspectRatioElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index)))
	}
	return &AspectRatioElementConfig_DEFAULT
}

func __AspectRatioElementConfigArray_GetValue(array *__AspectRatioElementConfigArray, index int32) AspectRatioElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index)))
	}
	return AspectRatioElementConfig_DEFAULT
}

func __AspectRatioElementConfigArray_Add(array *__AspectRatioElementConfigArray, item AspectRatioElementConfig) *AspectRatioElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(array.Length-1)))
	}
	return &AspectRatioElementConfig_DEFAULT
}

func __AspectRatioElementConfigArraySlice_Get(slice *__AspectRatioElementConfigArraySlice, index int32) *AspectRatioElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index)))
	}
	return &AspectRatioElementConfig_DEFAULT
}

func __AspectRatioElementConfigArray_RemoveSwapback(array *__AspectRatioElementConfigArray, index int32) AspectRatioElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed AspectRatioElementConfig = *(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index)))
		*(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index))) = *(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return AspectRatioElementConfig_DEFAULT
}

func __AspectRatioElementConfigArray_Set(array *__AspectRatioElementConfigArray, index int32, value AspectRatioElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*AspectRatioElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(AspectRatioElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __ImageElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *ImageElementConfig
}
type __ImageElementConfigArraySlice struct {
	Length        int32
	InternalArray *ImageElementConfig
}

var ImageElementConfig_DEFAULT ImageElementConfig = ImageElementConfig{}

func __ImageElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __ImageElementConfigArray {
	return __ImageElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*ImageElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(ImageElementConfig{})), arena))}
}

func __ImageElementConfigArray_Get(array *__ImageElementConfigArray, index int32) *ImageElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index)))
	}
	return &ImageElementConfig_DEFAULT
}

func __ImageElementConfigArray_GetValue(array *__ImageElementConfigArray, index int32) ImageElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index)))
	}
	return ImageElementConfig_DEFAULT
}

func __ImageElementConfigArray_Add(array *__ImageElementConfigArray, item ImageElementConfig) *ImageElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(array.Length-1)))
	}
	return &ImageElementConfig_DEFAULT
}

func __ImageElementConfigArraySlice_Get(slice *__ImageElementConfigArraySlice, index int32) *ImageElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*ImageElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index)))
	}
	return &ImageElementConfig_DEFAULT
}

func __ImageElementConfigArray_RemoveSwapback(array *__ImageElementConfigArray, index int32) ImageElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed ImageElementConfig = *(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index)))
		*(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index))) = *(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return ImageElementConfig_DEFAULT
}

func __ImageElementConfigArray_Set(array *__ImageElementConfigArray, index int32, value ImageElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*ImageElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ImageElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __FloatingElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *FloatingElementConfig
}
type __FloatingElementConfigArraySlice struct {
	Length        int32
	InternalArray *FloatingElementConfig
}

var FloatingElementConfig_DEFAULT FloatingElementConfig = FloatingElementConfig{}

func __FloatingElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __FloatingElementConfigArray {
	return __FloatingElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*FloatingElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(FloatingElementConfig{})), arena))}
}

func __FloatingElementConfigArray_Get(array *__FloatingElementConfigArray, index int32) *FloatingElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index)))
	}
	return &FloatingElementConfig_DEFAULT
}

func __FloatingElementConfigArray_GetValue(array *__FloatingElementConfigArray, index int32) FloatingElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index)))
	}
	return FloatingElementConfig_DEFAULT
}

func __FloatingElementConfigArray_Add(array *__FloatingElementConfigArray, item FloatingElementConfig) *FloatingElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(array.Length-1)))
	}
	return &FloatingElementConfig_DEFAULT
}

func __FloatingElementConfigArraySlice_Get(slice *__FloatingElementConfigArraySlice, index int32) *FloatingElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index)))
	}
	return &FloatingElementConfig_DEFAULT
}

func __FloatingElementConfigArray_RemoveSwapback(array *__FloatingElementConfigArray, index int32) FloatingElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed FloatingElementConfig = *(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index)))
		*(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index))) = *(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return FloatingElementConfig_DEFAULT
}

func __FloatingElementConfigArray_Set(array *__FloatingElementConfigArray, index int32, value FloatingElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*FloatingElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(FloatingElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __CustomElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *CustomElementConfig
}
type __CustomElementConfigArraySlice struct {
	Length        int32
	InternalArray *CustomElementConfig
}

var CustomElementConfig_DEFAULT CustomElementConfig = CustomElementConfig{}

func __CustomElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __CustomElementConfigArray {
	return __CustomElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*CustomElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(CustomElementConfig{})), arena))}
}

func __CustomElementConfigArray_Get(array *__CustomElementConfigArray, index int32) *CustomElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index)))
	}
	return &CustomElementConfig_DEFAULT
}

func __CustomElementConfigArray_GetValue(array *__CustomElementConfigArray, index int32) CustomElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index)))
	}
	return CustomElementConfig_DEFAULT
}

func __CustomElementConfigArray_Add(array *__CustomElementConfigArray, item CustomElementConfig) *CustomElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(array.Length-1)))
	}
	return &CustomElementConfig_DEFAULT
}

func __CustomElementConfigArraySlice_Get(slice *__CustomElementConfigArraySlice, index int32) *CustomElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*CustomElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index)))
	}
	return &CustomElementConfig_DEFAULT
}

func __CustomElementConfigArray_RemoveSwapback(array *__CustomElementConfigArray, index int32) CustomElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed CustomElementConfig = *(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index)))
		*(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index))) = *(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return CustomElementConfig_DEFAULT
}

func __CustomElementConfigArray_Set(array *__CustomElementConfigArray, index int32, value CustomElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*CustomElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(CustomElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __ClipElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *ClipElementConfig
}
type __ClipElementConfigArraySlice struct {
	Length        int32
	InternalArray *ClipElementConfig
}

var ClipElementConfig_DEFAULT ClipElementConfig = ClipElementConfig{Horizontal: false}

func __ClipElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __ClipElementConfigArray {
	return __ClipElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*ClipElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(ClipElementConfig{})), arena))}
}

func __ClipElementConfigArray_Get(array *__ClipElementConfigArray, index int32) *ClipElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index)))
	}
	return &ClipElementConfig_DEFAULT
}

func __ClipElementConfigArray_GetValue(array *__ClipElementConfigArray, index int32) ClipElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index)))
	}
	return ClipElementConfig_DEFAULT
}

func __ClipElementConfigArray_Add(array *__ClipElementConfigArray, item ClipElementConfig) *ClipElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(array.Length-1)))
	}
	return &ClipElementConfig_DEFAULT
}

func __ClipElementConfigArraySlice_Get(slice *__ClipElementConfigArraySlice, index int32) *ClipElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*ClipElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index)))
	}
	return &ClipElementConfig_DEFAULT
}

func __ClipElementConfigArray_RemoveSwapback(array *__ClipElementConfigArray, index int32) ClipElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed ClipElementConfig = *(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index)))
		*(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index))) = *(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return ClipElementConfig_DEFAULT
}

func __ClipElementConfigArray_Set(array *__ClipElementConfigArray, index int32, value ClipElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*ClipElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ClipElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __BorderElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *BorderElementConfig
}
type __BorderElementConfigArraySlice struct {
	Length        int32
	InternalArray *BorderElementConfig
}

var BorderElementConfig_DEFAULT BorderElementConfig = BorderElementConfig{}

func __BorderElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __BorderElementConfigArray {
	return __BorderElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*BorderElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(BorderElementConfig{})), arena))}
}

func __BorderElementConfigArray_Get(array *__BorderElementConfigArray, index int32) *BorderElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index)))
	}
	return &BorderElementConfig_DEFAULT
}

func __BorderElementConfigArray_GetValue(array *__BorderElementConfigArray, index int32) BorderElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index)))
	}
	return BorderElementConfig_DEFAULT
}

func __BorderElementConfigArray_Add(array *__BorderElementConfigArray, item BorderElementConfig) *BorderElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(array.Length-1)))
	}
	return &BorderElementConfig_DEFAULT
}

func __BorderElementConfigArraySlice_Get(slice *__BorderElementConfigArraySlice, index int32) *BorderElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*BorderElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index)))
	}
	return &BorderElementConfig_DEFAULT
}

func __BorderElementConfigArray_RemoveSwapback(array *__BorderElementConfigArray, index int32) BorderElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed BorderElementConfig = *(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index)))
		*(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index))) = *(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return BorderElementConfig_DEFAULT
}

func __BorderElementConfigArray_Set(array *__BorderElementConfigArray, index int32, value BorderElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*BorderElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(BorderElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __StringArray struct {
	Capacity      int32
	Length        int32
	InternalArray *String
}
type __StringArraySlice struct {
	Length        int32
	InternalArray *String
}

var String_DEFAULT String = String{IsStaticallyAllocated: false}

func __StringArray_Allocate_Arena(capacity int32, arena *Arena) __StringArray {
	return __StringArray{Capacity: capacity, Length: 0, InternalArray: (*String)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(String{})), arena))}
}

func __StringArray_Get(array *__StringArray, index int32) *String {
	if __Array_RangeCheck(index, array.Length) {
		return (*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(index)))
	}
	return &String_DEFAULT
}

func __StringArray_GetValue(array *__StringArray, index int32) String {
	if __Array_RangeCheck(index, array.Length) {
		return *(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(index)))
	}
	return String_DEFAULT
}

func __StringArray_Add(array *__StringArray, item String) *String {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(array.Length-1)))
	}
	return &String_DEFAULT
}

func __StringArraySlice_Get(slice *__StringArraySlice, index int32) *String {
	if __Array_RangeCheck(index, slice.Length) {
		return (*String)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(String{})*uintptr(index)))
	}
	return &String_DEFAULT
}

func __StringArray_RemoveSwapback(array *__StringArray, index int32) String {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed String = *(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(index)))
		*(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(index))) = *(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(array.Length)))
		return removed
	}
	return String_DEFAULT
}

func __StringArray_Set(array *__StringArray, index int32, value String) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*String)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(String{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __SharedElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *SharedElementConfig
}
type __SharedElementConfigArraySlice struct {
	Length        int32
	InternalArray *SharedElementConfig
}

var SharedElementConfig_DEFAULT SharedElementConfig = SharedElementConfig{}

func __SharedElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __SharedElementConfigArray {
	return __SharedElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*SharedElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(SharedElementConfig{})), arena))}
}

func __SharedElementConfigArray_Get(array *__SharedElementConfigArray, index int32) *SharedElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index)))
	}
	return &SharedElementConfig_DEFAULT
}

func __SharedElementConfigArray_GetValue(array *__SharedElementConfigArray, index int32) SharedElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index)))
	}
	return SharedElementConfig_DEFAULT
}

func __SharedElementConfigArray_Add(array *__SharedElementConfigArray, item SharedElementConfig) *SharedElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(array.Length-1)))
	}
	return &SharedElementConfig_DEFAULT
}

func __SharedElementConfigArraySlice_Get(slice *__SharedElementConfigArraySlice, index int32) *SharedElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*SharedElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index)))
	}
	return &SharedElementConfig_DEFAULT
}

func __SharedElementConfigArray_RemoveSwapback(array *__SharedElementConfigArray, index int32) SharedElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed SharedElementConfig = *(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index)))
		*(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index))) = *(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return SharedElementConfig_DEFAULT
}

func __SharedElementConfigArray_Set(array *__SharedElementConfigArray, index int32, value SharedElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*SharedElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(SharedElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type RenderCommandArraySlice struct {
	Length        int32
	InternalArray *RenderCommand
}

var RenderCommand_DEFAULT RenderCommand = RenderCommand{}

func RenderCommandArray_Allocate_Arena(capacity int32, arena *Arena) RenderCommandArray {
	return RenderCommandArray{Capacity: capacity, Length: 0, InternalArray: (*RenderCommand)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(RenderCommand{})), arena))}
}

func RenderCommandArray_Get(array *RenderCommandArray, index int32) *RenderCommand {
	if __Array_RangeCheck(index, array.Length) {
		return (*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index)))
	}
	return &RenderCommand_DEFAULT
}

func RenderCommandArray_GetValue(array *RenderCommandArray, index int32) RenderCommand {
	if __Array_RangeCheck(index, array.Length) {
		return *(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index)))
	}
	return RenderCommand_DEFAULT
}

func RenderCommandArray_Add(array *RenderCommandArray, item RenderCommand) *RenderCommand {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(array.Length-1)))
	}
	return &RenderCommand_DEFAULT
}

func RenderCommandArraySlice_Get(slice *RenderCommandArraySlice, index int32) *RenderCommand {
	if __Array_RangeCheck(index, slice.Length) {
		return (*RenderCommand)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index)))
	}
	return &RenderCommand_DEFAULT
}

func RenderCommandArray_RemoveSwapback(array *RenderCommandArray, index int32) RenderCommand {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed RenderCommand = *(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index)))
		*(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index))) = *(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(array.Length)))
		return removed
	}
	return RenderCommand_DEFAULT
}

func RenderCommandArray_Set(array *RenderCommandArray, index int32, value RenderCommand) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*RenderCommand)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(RenderCommand{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __ElementConfigType int32

const (
	__ELEMENT_CONFIG_TYPE_NONE = __ElementConfigType(iota)
	__ELEMENT_CONFIG_TYPE_BORDER
	__ELEMENT_CONFIG_TYPE_FLOATING
	__ELEMENT_CONFIG_TYPE_CLIP
	__ELEMENT_CONFIG_TYPE_ASPECT
	__ELEMENT_CONFIG_TYPE_IMAGE
	__ELEMENT_CONFIG_TYPE_TEXT
	__ELEMENT_CONFIG_TYPE_CUSTOM
	__ELEMENT_CONFIG_TYPE_SHARED
)

type ElementConfigUnion struct {
	// union
	TextElementConfig        *TextElementConfig
	AspectRatioElementConfig *AspectRatioElementConfig
	ImageElementConfig       *ImageElementConfig
	FloatingElementConfig    *FloatingElementConfig
	CustomElementConfig      *CustomElementConfig
	ClipElementConfig        *ClipElementConfig
	BorderElementConfig      *BorderElementConfig
	SharedElementConfig      *SharedElementConfig
}
type ElementConfig struct {
	Type   __ElementConfigType
	Config ElementConfigUnion
}
type __ElementConfigArray struct {
	Capacity      int32
	Length        int32
	InternalArray *ElementConfig
}
type __ElementConfigArraySlice struct {
	Length        int32
	InternalArray *ElementConfig
}

var ElementConfig_DEFAULT ElementConfig = ElementConfig{}

func __ElementConfigArray_Allocate_Arena(capacity int32, arena *Arena) __ElementConfigArray {
	return __ElementConfigArray{Capacity: capacity, Length: 0, InternalArray: (*ElementConfig)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(ElementConfig{})), arena))}
}

func __ElementConfigArray_Get(array *__ElementConfigArray, index int32) *ElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return (*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index)))
	}
	return &ElementConfig_DEFAULT
}

func __ElementConfigArray_GetValue(array *__ElementConfigArray, index int32) ElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		return *(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index)))
	}
	return ElementConfig_DEFAULT
}

func __ElementConfigArray_Add(array *__ElementConfigArray, item ElementConfig) *ElementConfig {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(array.Length-1)))
	}
	return &ElementConfig_DEFAULT
}

func __ElementConfigArraySlice_Get(slice *__ElementConfigArraySlice, index int32) *ElementConfig {
	if __Array_RangeCheck(index, slice.Length) {
		return (*ElementConfig)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index)))
	}
	return &ElementConfig_DEFAULT
}

func __ElementConfigArray_RemoveSwapback(array *__ElementConfigArray, index int32) ElementConfig {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed ElementConfig = *(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index)))
		*(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index))) = *(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(array.Length)))
		return removed
	}
	return ElementConfig_DEFAULT
}

func __ElementConfigArray_Set(array *__ElementConfigArray, index int32, value ElementConfig) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*ElementConfig)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __WrappedTextLine struct {
	Dimensions Dimensions
	Line       String
}
type __WrappedTextLineArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__WrappedTextLine
}
type __WrappedTextLineArraySlice struct {
	Length        int32
	InternalArray *__WrappedTextLine
}

var __WrappedTextLine_DEFAULT __WrappedTextLine = __WrappedTextLine{}

func __WrappedTextLineArray_Allocate_Arena(capacity int32, arena *Arena) __WrappedTextLineArray {
	return __WrappedTextLineArray{Capacity: capacity, Length: 0, InternalArray: (*__WrappedTextLine)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__WrappedTextLine{})), arena))}
}

func __WrappedTextLineArray_Get(array *__WrappedTextLineArray, index int32) *__WrappedTextLine {
	if __Array_RangeCheck(index, array.Length) {
		return (*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index)))
	}
	return &__WrappedTextLine_DEFAULT
}

func __WrappedTextLineArray_GetValue(array *__WrappedTextLineArray, index int32) __WrappedTextLine {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index)))
	}
	return __WrappedTextLine_DEFAULT
}

func __WrappedTextLineArray_Add(array *__WrappedTextLineArray, item __WrappedTextLine) *__WrappedTextLine {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(array.Length-1)))
	}
	return &__WrappedTextLine_DEFAULT
}

func __WrappedTextLineArraySlice_Get(slice *__WrappedTextLineArraySlice, index int32) *__WrappedTextLine {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index)))
	}
	return &__WrappedTextLine_DEFAULT
}

func __WrappedTextLineArray_RemoveSwapback(array *__WrappedTextLineArray, index int32) __WrappedTextLine {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __WrappedTextLine = *(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index)))
		*(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index))) = *(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(array.Length)))
		return removed
	}
	return __WrappedTextLine_DEFAULT
}

func __WrappedTextLineArray_Set(array *__WrappedTextLineArray, index int32, value __WrappedTextLine) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __TextElementData struct {
	Text                String
	PreferredDimensions Dimensions
	ElementIndex        int32
	WrappedLines        __WrappedTextLineArraySlice
}
type __TextElementDataArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__TextElementData
}
type __TextElementDataArraySlice struct {
	Length        int32
	InternalArray *__TextElementData
}

var __TextElementData_DEFAULT __TextElementData = __TextElementData{}

func __TextElementDataArray_Allocate_Arena(capacity int32, arena *Arena) __TextElementDataArray {
	return __TextElementDataArray{Capacity: capacity, Length: 0, InternalArray: (*__TextElementData)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__TextElementData{})), arena))}
}

func __TextElementDataArray_Get(array *__TextElementDataArray, index int32) *__TextElementData {
	if __Array_RangeCheck(index, array.Length) {
		return (*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index)))
	}
	return &__TextElementData_DEFAULT
}

func __TextElementDataArray_GetValue(array *__TextElementDataArray, index int32) __TextElementData {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index)))
	}
	return __TextElementData_DEFAULT
}

func __TextElementDataArray_Add(array *__TextElementDataArray, item __TextElementData) *__TextElementData {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(array.Length-1)))
	}
	return &__TextElementData_DEFAULT
}

func __TextElementDataArraySlice_Get(slice *__TextElementDataArraySlice, index int32) *__TextElementData {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__TextElementData)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index)))
	}
	return &__TextElementData_DEFAULT
}

func __TextElementDataArray_RemoveSwapback(array *__TextElementDataArray, index int32) __TextElementData {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __TextElementData = *(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index)))
		*(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index))) = *(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(array.Length)))
		return removed
	}
	return __TextElementData_DEFAULT
}

func __TextElementDataArray_Set(array *__TextElementDataArray, index int32, value __TextElementData) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__TextElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__TextElementData{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __LayoutElementChildren struct {
	Elements *int32
	Length   uint16
}
type LayoutElement struct {
	ChildrenOrTextContent struct {
		// union
		Children        __LayoutElementChildren
		TextElementData *__TextElementData
	}
	Dimensions     Dimensions
	MinDimensions  Dimensions
	LayoutConfig   *LayoutConfig
	ElementConfigs __ElementConfigArraySlice
	Id             uint32
}
type LayoutElementArray struct {
	Capacity      int32
	Length        int32
	InternalArray *LayoutElement
}
type LayoutElementArraySlice struct {
	Length        int32
	InternalArray *LayoutElement
}

var LayoutElement_DEFAULT LayoutElement = LayoutElement{}

func LayoutElementArray_Allocate_Arena(capacity int32, arena *Arena) LayoutElementArray {
	return LayoutElementArray{Capacity: capacity, Length: 0, InternalArray: (*LayoutElement)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(LayoutElement{})), arena))}
}

func LayoutElementArray_Get(array *LayoutElementArray, index int32) *LayoutElement {
	if __Array_RangeCheck(index, array.Length) {
		return (*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index)))
	}
	return &LayoutElement_DEFAULT
}

func LayoutElementArray_GetValue(array *LayoutElementArray, index int32) LayoutElement {
	if __Array_RangeCheck(index, array.Length) {
		return *(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index)))
	}
	return LayoutElement_DEFAULT
}

func LayoutElementArray_Add(array *LayoutElementArray, item LayoutElement) *LayoutElement {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(array.Length-1)))
	}
	return &LayoutElement_DEFAULT
}

func LayoutElementArraySlice_Get(slice *LayoutElementArraySlice, index int32) *LayoutElement {
	if __Array_RangeCheck(index, slice.Length) {
		return (*LayoutElement)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index)))
	}
	return &LayoutElement_DEFAULT
}

func LayoutElementArray_RemoveSwapback(array *LayoutElementArray, index int32) LayoutElement {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed LayoutElement = *(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index)))
		*(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index))) = *(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(array.Length)))
		return removed
	}
	return LayoutElement_DEFAULT
}

func LayoutElementArray_Set(array *LayoutElementArray, index int32, value LayoutElement) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*LayoutElement)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElement{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __ScrollContainerDataInternal struct {
	LayoutElement       *LayoutElement
	BoundingBox         BoundingBox
	ContentSize         Dimensions
	ScrollOrigin        Vector2
	PointerOrigin       Vector2
	ScrollMomentum      Vector2
	ScrollPosition      Vector2
	PreviousDelta       Vector2
	MomentumTime        float32
	ElementId           uint32
	OpenThisFrame       bool
	PointerScrollActive bool
}
type __ScrollContainerDataInternalArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__ScrollContainerDataInternal
}
type __ScrollContainerDataInternalArraySlice struct {
	Length        int32
	InternalArray *__ScrollContainerDataInternal
}

var __ScrollContainerDataInternal_DEFAULT __ScrollContainerDataInternal = __ScrollContainerDataInternal{}

func __ScrollContainerDataInternalArray_Allocate_Arena(capacity int32, arena *Arena) __ScrollContainerDataInternalArray {
	return __ScrollContainerDataInternalArray{Capacity: capacity, Length: 0, InternalArray: (*__ScrollContainerDataInternal)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__ScrollContainerDataInternal{})), arena))}
}

func __ScrollContainerDataInternalArray_Get(array *__ScrollContainerDataInternalArray, index int32) *__ScrollContainerDataInternal {
	if __Array_RangeCheck(index, array.Length) {
		return (*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index)))
	}
	return &__ScrollContainerDataInternal_DEFAULT
}

func __ScrollContainerDataInternalArray_GetValue(array *__ScrollContainerDataInternalArray, index int32) __ScrollContainerDataInternal {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index)))
	}
	return __ScrollContainerDataInternal_DEFAULT
}

func __ScrollContainerDataInternalArray_Add(array *__ScrollContainerDataInternalArray, item __ScrollContainerDataInternal) *__ScrollContainerDataInternal {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(array.Length-1)))
	}
	return &__ScrollContainerDataInternal_DEFAULT
}

func __ScrollContainerDataInternalArraySlice_Get(slice *__ScrollContainerDataInternalArraySlice, index int32) *__ScrollContainerDataInternal {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index)))
	}
	return &__ScrollContainerDataInternal_DEFAULT
}

func __ScrollContainerDataInternalArray_RemoveSwapback(array *__ScrollContainerDataInternalArray, index int32) __ScrollContainerDataInternal {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __ScrollContainerDataInternal = *(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index)))
		*(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index))) = *(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(array.Length)))
		return removed
	}
	return __ScrollContainerDataInternal_DEFAULT
}

func __ScrollContainerDataInternalArray_Set(array *__ScrollContainerDataInternalArray, index int32, value __ScrollContainerDataInternal) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__ScrollContainerDataInternal)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__ScrollContainerDataInternal{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __DebugElementData struct {
	Collision bool
	Collapsed bool
}
type __DebugElementDataArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__DebugElementData
}
type __DebugElementDataArraySlice struct {
	Length        int32
	InternalArray *__DebugElementData
}

var __DebugElementData_DEFAULT __DebugElementData = __DebugElementData{Collision: false}

func __DebugElementDataArray_Allocate_Arena(capacity int32, arena *Arena) __DebugElementDataArray {
	return __DebugElementDataArray{Capacity: capacity, Length: 0, InternalArray: (*__DebugElementData)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__DebugElementData{})), arena))}
}

func __DebugElementDataArray_Get(array *__DebugElementDataArray, index int32) *__DebugElementData {
	if __Array_RangeCheck(index, array.Length) {
		return (*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index)))
	}
	return &__DebugElementData_DEFAULT
}

func __DebugElementDataArray_GetValue(array *__DebugElementDataArray, index int32) __DebugElementData {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index)))
	}
	return __DebugElementData_DEFAULT
}

func __DebugElementDataArray_Add(array *__DebugElementDataArray, item __DebugElementData) *__DebugElementData {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(array.Length-1)))
	}
	return &__DebugElementData_DEFAULT
}

func __DebugElementDataArraySlice_Get(slice *__DebugElementDataArraySlice, index int32) *__DebugElementData {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__DebugElementData)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index)))
	}
	return &__DebugElementData_DEFAULT
}

func __DebugElementDataArray_RemoveSwapback(array *__DebugElementDataArray, index int32) __DebugElementData {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __DebugElementData = *(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index)))
		*(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index))) = *(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(array.Length)))
		return removed
	}
	return __DebugElementData_DEFAULT
}

func __DebugElementDataArray_Set(array *__DebugElementDataArray, index int32, value __DebugElementData) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__DebugElementData)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__DebugElementData{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type LayoutElementHashMapItem struct {
	BoundingBox           BoundingBox
	ElementId             ElementId
	LayoutElement         *LayoutElement
	OnHoverFunction       func(elementId ElementId, pointerInfo PointerData, userData int64)
	HoverFunctionUserData any
	NextIndex             int32
	Generation            uint32
	DebugData             *__DebugElementData
}
type __LayoutElementHashMapItemArray struct {
	Capacity      int32
	Length        int32
	InternalArray *LayoutElementHashMapItem
}
type __LayoutElementHashMapItemArraySlice struct {
	Length        int32
	InternalArray *LayoutElementHashMapItem
}

var LayoutElementHashMapItem_DEFAULT LayoutElementHashMapItem = LayoutElementHashMapItem{}

func __LayoutElementHashMapItemArray_Allocate_Arena(capacity int32, arena *Arena) __LayoutElementHashMapItemArray {
	return __LayoutElementHashMapItemArray{Capacity: capacity, Length: 0, InternalArray: (*LayoutElementHashMapItem)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(LayoutElementHashMapItem{})), arena))}
}

func __LayoutElementHashMapItemArray_Get(array *__LayoutElementHashMapItemArray, index int32) *LayoutElementHashMapItem {
	if __Array_RangeCheck(index, array.Length) {
		return (*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index)))
	}
	return &LayoutElementHashMapItem_DEFAULT
}

func __LayoutElementHashMapItemArray_GetValue(array *__LayoutElementHashMapItemArray, index int32) LayoutElementHashMapItem {
	if __Array_RangeCheck(index, array.Length) {
		return *(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index)))
	}
	return LayoutElementHashMapItem_DEFAULT
}

func __LayoutElementHashMapItemArray_Add(array *__LayoutElementHashMapItemArray, item LayoutElementHashMapItem) *LayoutElementHashMapItem {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(array.Length-1)))
	}
	return &LayoutElementHashMapItem_DEFAULT
}

func __LayoutElementHashMapItemArraySlice_Get(slice *__LayoutElementHashMapItemArraySlice, index int32) *LayoutElementHashMapItem {
	if __Array_RangeCheck(index, slice.Length) {
		return (*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index)))
	}
	return &LayoutElementHashMapItem_DEFAULT
}

func __LayoutElementHashMapItemArray_RemoveSwapback(array *__LayoutElementHashMapItemArray, index int32) LayoutElementHashMapItem {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed LayoutElementHashMapItem = *(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index)))
		*(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index))) = *(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(array.Length)))
		return removed
	}
	return LayoutElementHashMapItem_DEFAULT
}

func __LayoutElementHashMapItemArray_Set(array *__LayoutElementHashMapItemArray, index int32, value LayoutElementHashMapItem) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*LayoutElementHashMapItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(LayoutElementHashMapItem{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __MeasuredWord struct {
	StartOffset int32
	Length      int32
	Width       float32
	Next        int32
}
type __MeasuredWordArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__MeasuredWord
}
type __MeasuredWordArraySlice struct {
	Length        int32
	InternalArray *__MeasuredWord
}

var __MeasuredWord_DEFAULT __MeasuredWord = __MeasuredWord{}

func __MeasuredWordArray_Allocate_Arena(capacity int32, arena *Arena) __MeasuredWordArray {
	return __MeasuredWordArray{Capacity: capacity, Length: 0, InternalArray: (*__MeasuredWord)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__MeasuredWord{})), arena))}
}

func __MeasuredWordArray_Get(array *__MeasuredWordArray, index int32) *__MeasuredWord {
	if __Array_RangeCheck(index, array.Length) {
		return (*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index)))
	}
	return &__MeasuredWord_DEFAULT
}

func __MeasuredWordArray_GetValue(array *__MeasuredWordArray, index int32) __MeasuredWord {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index)))
	}
	return __MeasuredWord_DEFAULT
}

func __MeasuredWordArray_Add(array *__MeasuredWordArray, item __MeasuredWord) *__MeasuredWord {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(array.Length-1)))
	}
	return &__MeasuredWord_DEFAULT
}

func __MeasuredWordArraySlice_Get(slice *__MeasuredWordArraySlice, index int32) *__MeasuredWord {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__MeasuredWord)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index)))
	}
	return &__MeasuredWord_DEFAULT
}

func __MeasuredWordArray_RemoveSwapback(array *__MeasuredWordArray, index int32) __MeasuredWord {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __MeasuredWord = *(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index)))
		*(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index))) = *(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(array.Length)))
		return removed
	}
	return __MeasuredWord_DEFAULT
}

func __MeasuredWordArray_Set(array *__MeasuredWordArray, index int32, value __MeasuredWord) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__MeasuredWord)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasuredWord{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __MeasureTextCacheItem struct {
	UnwrappedDimensions     Dimensions
	MeasuredWordsStartIndex int32
	MinWidth                float32
	ContainsNewlines        bool
	Id                      uint32
	NextIndex               int32
	Generation              uint32
}
type __MeasureTextCacheItemArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__MeasureTextCacheItem
}
type __MeasureTextCacheItemArraySlice struct {
	Length        int32
	InternalArray *__MeasureTextCacheItem
}

var __MeasureTextCacheItem_DEFAULT __MeasureTextCacheItem = __MeasureTextCacheItem{}

func __MeasureTextCacheItemArray_Allocate_Arena(capacity int32, arena *Arena) __MeasureTextCacheItemArray {
	return __MeasureTextCacheItemArray{Capacity: capacity, Length: 0, InternalArray: (*__MeasureTextCacheItem)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__MeasureTextCacheItem{})), arena))}
}

func __MeasureTextCacheItemArray_Get(array *__MeasureTextCacheItemArray, index int32) *__MeasureTextCacheItem {
	if __Array_RangeCheck(index, array.Length) {
		return (*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index)))
	}
	return &__MeasureTextCacheItem_DEFAULT
}

func __MeasureTextCacheItemArray_GetValue(array *__MeasureTextCacheItemArray, index int32) __MeasureTextCacheItem {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index)))
	}
	return __MeasureTextCacheItem_DEFAULT
}

func __MeasureTextCacheItemArray_Add(array *__MeasureTextCacheItemArray, item __MeasureTextCacheItem) *__MeasureTextCacheItem {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(array.Length-1)))
	}
	return &__MeasureTextCacheItem_DEFAULT
}

func __MeasureTextCacheItemArraySlice_Get(slice *__MeasureTextCacheItemArraySlice, index int32) *__MeasureTextCacheItem {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index)))
	}
	return &__MeasureTextCacheItem_DEFAULT
}

func __MeasureTextCacheItemArray_RemoveSwapback(array *__MeasureTextCacheItemArray, index int32) __MeasureTextCacheItem {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __MeasureTextCacheItem = *(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index)))
		*(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index))) = *(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(array.Length)))
		return removed
	}
	return __MeasureTextCacheItem_DEFAULT
}

func __MeasureTextCacheItemArray_Set(array *__MeasureTextCacheItemArray, index int32, value __MeasureTextCacheItem) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__MeasureTextCacheItem)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__MeasureTextCacheItem{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __LayoutElementTreeNode struct {
	LayoutElement   *LayoutElement
	Position        Vector2
	NextChildOffset Vector2
}
type __LayoutElementTreeNodeArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__LayoutElementTreeNode
}
type __LayoutElementTreeNodeArraySlice struct {
	Length        int32
	InternalArray *__LayoutElementTreeNode
}

var __LayoutElementTreeNode_DEFAULT __LayoutElementTreeNode = __LayoutElementTreeNode{}

func __LayoutElementTreeNodeArray_Allocate_Arena(capacity int32, arena *Arena) __LayoutElementTreeNodeArray {
	return __LayoutElementTreeNodeArray{Capacity: capacity, Length: 0, InternalArray: (*__LayoutElementTreeNode)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__LayoutElementTreeNode{})), arena))}
}

func __LayoutElementTreeNodeArray_Get(array *__LayoutElementTreeNodeArray, index int32) *__LayoutElementTreeNode {
	if __Array_RangeCheck(index, array.Length) {
		return (*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index)))
	}
	return &__LayoutElementTreeNode_DEFAULT
}

func __LayoutElementTreeNodeArray_GetValue(array *__LayoutElementTreeNodeArray, index int32) __LayoutElementTreeNode {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index)))
	}
	return __LayoutElementTreeNode_DEFAULT
}

func __LayoutElementTreeNodeArray_Add(array *__LayoutElementTreeNodeArray, item __LayoutElementTreeNode) *__LayoutElementTreeNode {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(array.Length-1)))
	}
	return &__LayoutElementTreeNode_DEFAULT
}

func __LayoutElementTreeNodeArraySlice_Get(slice *__LayoutElementTreeNodeArraySlice, index int32) *__LayoutElementTreeNode {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index)))
	}
	return &__LayoutElementTreeNode_DEFAULT
}

func __LayoutElementTreeNodeArray_RemoveSwapback(array *__LayoutElementTreeNodeArray, index int32) __LayoutElementTreeNode {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __LayoutElementTreeNode = *(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index)))
		*(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index))) = *(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(array.Length)))
		return removed
	}
	return __LayoutElementTreeNode_DEFAULT
}

func __LayoutElementTreeNodeArray_Set(array *__LayoutElementTreeNodeArray, index int32, value __LayoutElementTreeNode) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

type __LayoutElementTreeRoot struct {
	LayoutElementIndex int32
	ParentId           uint32
	ClipElementId      uint32
	ZIndex             int16
	PointerOffset      Vector2
}
type __LayoutElementTreeRootArray struct {
	Capacity      int32
	Length        int32
	InternalArray *__LayoutElementTreeRoot
}
type __LayoutElementTreeRootArraySlice struct {
	Length        int32
	InternalArray *__LayoutElementTreeRoot
}

var __LayoutElementTreeRoot_DEFAULT __LayoutElementTreeRoot = __LayoutElementTreeRoot{}

func __LayoutElementTreeRootArray_Allocate_Arena(capacity int32, arena *Arena) __LayoutElementTreeRootArray {
	return __LayoutElementTreeRootArray{Capacity: capacity, Length: 0, InternalArray: (*__LayoutElementTreeRoot)(__Array_Allocate_Arena(capacity, uint32(unsafe.Sizeof(__LayoutElementTreeRoot{})), arena))}
}

func __LayoutElementTreeRootArray_Get(array *__LayoutElementTreeRootArray, index int32) *__LayoutElementTreeRoot {
	if __Array_RangeCheck(index, array.Length) {
		return (*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index)))
	}
	return &__LayoutElementTreeRoot_DEFAULT
}

func __LayoutElementTreeRootArray_GetValue(array *__LayoutElementTreeRootArray, index int32) __LayoutElementTreeRoot {
	if __Array_RangeCheck(index, array.Length) {
		return *(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index)))
	}
	return __LayoutElementTreeRoot_DEFAULT
}

func __LayoutElementTreeRootArray_Add(array *__LayoutElementTreeRootArray, item __LayoutElementTreeRoot) *__LayoutElementTreeRoot {
	if __Array_AddCapacityCheck(array.Length, array.Capacity) {
		*(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(array.Length-1)))
	}
	return &__LayoutElementTreeRoot_DEFAULT
}

func __LayoutElementTreeRootArraySlice_Get(slice *__LayoutElementTreeRootArraySlice, index int32) *__LayoutElementTreeRoot {
	if __Array_RangeCheck(index, slice.Length) {
		return (*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(slice.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index)))
	}
	return &__LayoutElementTreeRoot_DEFAULT
}

func __LayoutElementTreeRootArray_RemoveSwapback(array *__LayoutElementTreeRootArray, index int32) __LayoutElementTreeRoot {
	if __Array_RangeCheck(index, array.Length) {
		array.Length--
		var removed __LayoutElementTreeRoot = *(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index)))
		*(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index))) = *(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(array.Length)))
		return removed
	}
	return __LayoutElementTreeRoot_DEFAULT
}

func __LayoutElementTreeRootArray_Set(array *__LayoutElementTreeRootArray, index int32, value __LayoutElementTreeRoot) {
	if __Array_RangeCheck(index, array.Capacity) {
		*(*__LayoutElementTreeRoot)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__LayoutElementTreeRoot{})*uintptr(index))) = value
		if index < array.Length {
			/* (001) */
		} else {
			array.Length = index + 1
		}
	}
}

func __Context_Allocate_Arena(arena *Arena) *Context {
	var totalSizeBytes uint64 = uint64(unsafe.Sizeof(Context{}))
	if totalSizeBytes > arena.Capacity {
		return nil
	}
	arena.NextAllocation += totalSizeBytes
	return (*Context)(unsafe.Pointer(arena.Memory))
}

func __WriteStringToCharBuffer(buffer *__charArray, string_ String) String {
	for i := int32(0); i < string_.Length; i++ {
		*(*byte)(unsafe.Add(unsafe.Pointer(buffer.InternalArray), buffer.Length+i)) = *(*byte)(unsafe.Add(unsafe.Pointer(string_.Chars), i))
	}
	buffer.Length += string_.Length
	return String{Length: string_.Length, Chars: ((*byte)(unsafe.Add(unsafe.Pointer((*byte)(unsafe.Add(unsafe.Pointer(buffer.InternalArray), buffer.Length))), -string_.Length)))}
}

var (
	__MeasureText       func(text StringSlice, config *TextElementConfig, userData unsafe.Pointer) Dimensions
	__QueryScrollOffset func(elementId uint32, userData unsafe.Pointer) Vector2
)

func __GetOpenLayoutElement() *LayoutElement {
	var context *Context = GetCurrentContext()
	return LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-1))
}

func __GetParentElementId() uint32 {
	var context *Context = GetCurrentContext()
	return LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-2)).Id
}

func __StoreLayoutConfig(config LayoutConfig) *LayoutConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &LAYOUT_DEFAULT
	}
	return __LayoutConfigArray_Add(&GetCurrentContext().layoutConfigs, config)
}

func __StoreTextElementConfig(config TextElementConfig) *TextElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &TextElementConfig_DEFAULT
	}
	return __TextElementConfigArray_Add(&GetCurrentContext().textElementConfigs, config)
}

func __StoreAspectRatioElementConfig(config AspectRatioElementConfig) *AspectRatioElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &AspectRatioElementConfig_DEFAULT
	}
	return __AspectRatioElementConfigArray_Add(&GetCurrentContext().AspectRatioElementConfigs, config)
}

func __StoreImageElementConfig(config ImageElementConfig) *ImageElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &ImageElementConfig_DEFAULT
	}
	return __ImageElementConfigArray_Add(&GetCurrentContext().imageElementConfigs, config)
}

func __StoreFloatingElementConfig(config FloatingElementConfig) *FloatingElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &FloatingElementConfig_DEFAULT
	}
	return __FloatingElementConfigArray_Add(&GetCurrentContext().floatingElementConfigs, config)
}

func __StoreCustomElementConfig(config CustomElementConfig) *CustomElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &CustomElementConfig_DEFAULT
	}
	return __CustomElementConfigArray_Add(&GetCurrentContext().customElementConfigs, config)
}

func __StoreClipElementConfig(config ClipElementConfig) *ClipElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &ClipElementConfig_DEFAULT
	}
	return __ClipElementConfigArray_Add(&GetCurrentContext().ClipElementConfigs, config)
}

func __StoreBorderElementConfig(config BorderElementConfig) *BorderElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &BorderElementConfig_DEFAULT
	}
	return __BorderElementConfigArray_Add(&GetCurrentContext().borderElementConfigs, config)
}

func __StoreSharedElementConfig(config SharedElementConfig) *SharedElementConfig {
	if GetCurrentContext().booleanWarnings.MaxElementsExceeded {
		return &SharedElementConfig_DEFAULT
	}
	return __SharedElementConfigArray_Add(&GetCurrentContext().sharedElementConfigs, config)
}

func __AttachElementConfig(config ElementConfigUnion, type_ __ElementConfigType) ElementConfig {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return ElementConfig{}
	}
	var openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	openLayoutElement.ElementConfigs.Length++
	return *__ElementConfigArray_Add(&context.elementConfigs, ElementConfig{Type: type_, Config: config})
}

func __FindElementConfigWithType(element *LayoutElement, type_ __ElementConfigType) ElementConfigUnion {
	for i := int32(0); i < element.ElementConfigs.Length; i++ {
		var config *ElementConfig = __ElementConfigArraySlice_Get(&element.ElementConfigs, i)
		if config.Type == type_ {
			return config.Config
		}
	}
	return ElementConfigUnion{}
}

func __HashNumber(offset uint32, seed uint32) ElementId {
	var hash uint32 = seed
	hash += offset + 48
	hash += hash << 10
	hash ^= hash >> 6
	hash += hash << 3
	hash ^= hash >> 11
	hash += hash << 15
	return ElementId{Id: hash + 1, Offset: offset, BaseId: seed, StringId: __STRING_DEFAULT}
}

func __HashString(key String, seed uint32) ElementId {
	var hash uint32 = seed
	for i := int32(0); i < key.Length; i++ {
		hash += uint32(*(*byte)(unsafe.Add(unsafe.Pointer(key.Chars), i)))
		hash += hash << 10
		hash ^= hash >> 6
	}
	hash += hash << 3
	hash ^= hash >> 11
	hash += hash << 15
	return ElementId{Id: hash + 1, Offset: 0, BaseId: hash + 1, StringId: key}
}

func __HashStringWithOffset(key String, offset uint32, seed uint32) ElementId {
	var (
		hash uint32 = 0
		base uint32 = seed
	)
	for i := int32(0); i < key.Length; i++ {
		base += uint32(*(*byte)(unsafe.Add(unsafe.Pointer(key.Chars), i)))
		base += base << 10
		base ^= base >> 6
	}
	hash = base
	hash += offset
	hash += hash << 10
	hash ^= hash >> 6
	hash += hash << 3
	base += base << 3
	hash ^= hash >> 11
	base ^= base >> 11
	hash += hash << 15
	base += base << 15
	return ElementId{Id: hash + 1, Offset: offset, BaseId: base + 1, StringId: key}
}

func __HashData(data *uint8, length uint64) uint64 {
	var hash uint64 = 0
	for i := uint64(0); i < length; i++ {
		hash += uint64(*(*uint8)(unsafe.Add(unsafe.Pointer(data), i)))
		hash += hash << 10
		hash ^= hash >> 6
	}
	return hash
}

func __HashStringContentsWithConfig(text *String, config *TextElementConfig) uint32 {
	var hash uint32 = 0
	if text.IsStaticallyAllocated {
		hash += uint32(uint64(uintptr(unsafe.Pointer(text.Chars))))
		hash += hash << 10
		hash ^= hash >> 6
		hash += uint32(text.Length)
		hash += hash << 10
		hash ^= hash >> 6
	} else {
		hash = uint32(__HashData((*uint8)(unsafe.Pointer(text.Chars)), uint64(text.Length)) % math.MaxUint32)
	}
	hash += uint32(config.FontId)
	hash += hash << 10
	hash ^= hash >> 6
	hash += uint32(config.FontSize)
	hash += hash << 10
	hash ^= hash >> 6
	hash += uint32(config.LetterSpacing)
	hash += hash << 10
	hash ^= hash >> 6
	hash += hash << 3
	hash ^= hash >> 11
	hash += hash << 15
	return hash + 1
}

func __AddMeasuredWord(word __MeasuredWord, previousWord *__MeasuredWord) *__MeasuredWord {
	var context *Context = GetCurrentContext()
	if context.measuredWordsFreeList.Length > 0 {
		var newItemIndex uint32 = uint32(__int32_tArray_GetValue(&context.measuredWordsFreeList, context.measuredWordsFreeList.Length-1))
		context.measuredWordsFreeList.Length--
		__MeasuredWordArray_Set(&context.measuredWords, int32(newItemIndex), word)
		previousWord.Next = int32(newItemIndex)
		return __MeasuredWordArray_Get(&context.measuredWords, int32(newItemIndex))
	} else {
		previousWord.Next = context.measuredWords.Length
		return __MeasuredWordArray_Add(&context.measuredWords, word)
	}
}

func __MeasureTextCached(text *String, config *TextElementConfig) *__MeasureTextCacheItem {
	var context *Context = GetCurrentContext()
	if __MeasureText == nil {
		if !context.booleanWarnings.TextMeasurementFunctionNotSet {
			context.booleanWarnings.TextMeasurementFunctionNotSet = true
			context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_TEXT_MEASUREMENT_FUNCTION_NOT_PROVIDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay's internal MeasureText function is null. You may have forgotten to call SetMeasureTextFunction(), or passed a NULL function pointer by mistake.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay's internal MeasureText function is null. You may have forgotten to call SetMeasureTextFunction(), or passed a NULL function pointer by mistake.")}, UserData: context.errorHandler.UserData})
		}
		return &__MeasureTextCacheItem_DEFAULT
	}
	var id uint32 = __HashStringContentsWithConfig(text, config)
	var hashBucket uint32 = id % uint32(context.maxMeasureTextCacheWordCount/32)
	var elementIndexPrevious int32 = 0
	var elementIndex int32 = *(*int32)(unsafe.Add(unsafe.Pointer(context.measureTextHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket)))
	for elementIndex != 0 {
		var hashEntry *__MeasureTextCacheItem = __MeasureTextCacheItemArray_Get(&context.measureTextHashMapInternal, elementIndex)
		if hashEntry.Id == id {
			hashEntry.Generation = context.generation
			return hashEntry
		}
		if context.generation-hashEntry.Generation > 2 {
			var nextWordIndex int32 = hashEntry.MeasuredWordsStartIndex
			for nextWordIndex != -1 {
				var measuredWord *__MeasuredWord = __MeasuredWordArray_Get(&context.measuredWords, nextWordIndex)
				__int32_tArray_Add(&context.measuredWordsFreeList, nextWordIndex)
				nextWordIndex = measuredWord.Next
			}
			var nextIndex int32 = hashEntry.NextIndex
			__MeasureTextCacheItemArray_Set(&context.measureTextHashMapInternal, elementIndex, __MeasureTextCacheItem{MeasuredWordsStartIndex: -1})
			__int32_tArray_Add(&context.measureTextHashMapInternalFreeList, elementIndex)
			if elementIndexPrevious == 0 {
				*(*int32)(unsafe.Add(unsafe.Pointer(context.measureTextHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket))) = nextIndex
			} else {
				var previousHashEntry *__MeasureTextCacheItem = __MeasureTextCacheItemArray_Get(&context.measureTextHashMapInternal, elementIndexPrevious)
				previousHashEntry.NextIndex = nextIndex
			}
			elementIndex = nextIndex
		} else {
			elementIndexPrevious = elementIndex
			elementIndex = hashEntry.NextIndex
		}
	}
	var newItemIndex int32 = 0
	var newCacheItem __MeasureTextCacheItem = __MeasureTextCacheItem{MeasuredWordsStartIndex: -1, Id: id, Generation: context.generation}
	var measured *__MeasureTextCacheItem = nil
	if context.measureTextHashMapInternalFreeList.Length > 0 {
		newItemIndex = __int32_tArray_GetValue(&context.measureTextHashMapInternalFreeList, context.measureTextHashMapInternalFreeList.Length-1)
		context.measureTextHashMapInternalFreeList.Length--
		__MeasureTextCacheItemArray_Set(&context.measureTextHashMapInternal, newItemIndex, newCacheItem)
		measured = __MeasureTextCacheItemArray_Get(&context.measureTextHashMapInternal, newItemIndex)
	} else {
		if context.measureTextHashMapInternal.Length == context.measureTextHashMapInternal.Capacity-1 {
			if !context.booleanWarnings.MaxTextMeasureCacheExceeded {
				context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay ran out of capacity while attempting to measure text elements. Try using SetMaxElementCount() with a higher value.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay ran out of capacity while attempting to measure text elements. Try using SetMaxElementCount() with a higher value.")}, UserData: context.errorHandler.UserData})
				context.booleanWarnings.MaxTextMeasureCacheExceeded = true
			}
			return &__MeasureTextCacheItem_DEFAULT
		}
		measured = __MeasureTextCacheItemArray_Add(&context.measureTextHashMapInternal, newCacheItem)
		newItemIndex = context.measureTextHashMapInternal.Length - 1
	}
	var start int32 = 0
	var end int32 = 0
	var lineWidth float32 = 0
	var measuredWidth float32 = 0
	var measuredHeight float32 = 0
	var spaceWidth float32 = __MeasureText(StringSlice{Length: 1, Chars: __SPACECHAR.Chars, BaseChars: __SPACECHAR.Chars}, config, context.measureTextUserData.(unsafe.Pointer)).Width
	var tempWord __MeasuredWord = __MeasuredWord{Next: -1}
	var previousWord *__MeasuredWord = &tempWord
	for end < text.Length {
		if context.measuredWords.Length == context.measuredWords.Capacity-1 {
			if !context.booleanWarnings.MaxTextMeasureCacheExceeded {
				context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_TEXT_MEASUREMENT_CAPACITY_EXCEEDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay has run out of space in it's internal text measurement cache. Try using SetMaxMeasureTextCacheWordCount() (default 16384, with 1 unit storing 1 measured word).") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay has run out of space in it's internal text measurement cache. Try using SetMaxMeasureTextCacheWordCount() (default 16384, with 1 unit storing 1 measured word).")}, UserData: context.errorHandler.UserData})
				context.booleanWarnings.MaxTextMeasureCacheExceeded = true
			}
			return &__MeasureTextCacheItem_DEFAULT
		}
		var current int8 = int8(*(*byte)(unsafe.Add(unsafe.Pointer(text.Chars), end)))
		if int32(current) == ' ' || int32(current) == '\n' {
			var (
				length     int32      = end - start
				dimensions Dimensions = Dimensions{}
			)
			if length > 0 {
				dimensions = __MeasureText(StringSlice{Length: length, Chars: (*byte)(unsafe.Add(unsafe.Pointer(text.Chars), start)), BaseChars: text.Chars}, config, context.measureTextUserData.(unsafe.Pointer))
			}
			if dimensions.Width > measured.MinWidth {
				measured.MinWidth = dimensions.Width
			} else {
				/* (022) */
			}
			if measuredHeight > dimensions.Height {
				/* (002) */
			} else {
				measuredHeight = dimensions.Height
			}
			if int32(current) == ' ' {
				dimensions.Width += spaceWidth
				previousWord = __AddMeasuredWord(__MeasuredWord{StartOffset: start, Length: length + 1, Width: dimensions.Width, Next: -1}, previousWord)
				lineWidth += dimensions.Width
			}
			if int32(current) == '\n' {
				if length > 0 {
					previousWord = __AddMeasuredWord(__MeasuredWord{StartOffset: start, Length: length, Width: dimensions.Width, Next: -1}, previousWord)
				}
				previousWord = __AddMeasuredWord(__MeasuredWord{StartOffset: end + 1, Length: 0, Width: 0, Next: -1}, previousWord)
				lineWidth += dimensions.Width
				if lineWidth > measuredWidth {
					measuredWidth = lineWidth
				} else {
					/* (003) */
				}
				measured.ContainsNewlines = true
				lineWidth = 0
			}
			start = end + 1
		}
		end++
	}
	if end-start > 0 {
		var dimensions Dimensions = __MeasureText(StringSlice{Length: end - start, Chars: (*byte)(unsafe.Add(unsafe.Pointer(text.Chars), start)), BaseChars: text.Chars}, config, context.measureTextUserData.(unsafe.Pointer))
		__AddMeasuredWord(__MeasuredWord{StartOffset: start, Length: end - start, Width: dimensions.Width, Next: -1}, previousWord)
		lineWidth += dimensions.Width
		if measuredHeight > dimensions.Height {
			/* (002) */
		} else {
			measuredHeight = dimensions.Height
		}
		if dimensions.Width > measured.MinWidth {
			measured.MinWidth = dimensions.Width
		} else {
			/* (022) */
		}
	}
	measuredWidth = (func() float32 {
		if lineWidth > measuredWidth {
			return lineWidth
		}
		return measuredWidth
	}()) - float32(config.LetterSpacing)
	measured.MeasuredWordsStartIndex = tempWord.Next
	measured.UnwrappedDimensions.Width = measuredWidth
	measured.UnwrappedDimensions.Height = measuredHeight
	if elementIndexPrevious != 0 {
		__MeasureTextCacheItemArray_Get(&context.measureTextHashMapInternal, elementIndexPrevious).NextIndex = newItemIndex
	} else {
		*(*int32)(unsafe.Add(unsafe.Pointer(context.measureTextHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket))) = newItemIndex
	}
	return measured
}

func __PointIsInsideRect(point Vector2, rect BoundingBox) bool {
	return point.X >= rect.X && point.X <= rect.X+rect.Width && point.Y >= rect.Y && point.Y <= rect.Y+rect.Height
}

func __AddHashMapItem(elementId ElementId, layoutElement *LayoutElement) *LayoutElementHashMapItem {
	var context *Context = GetCurrentContext()
	if context.layoutElementsHashMapInternal.Length == context.layoutElementsHashMapInternal.Capacity-1 {
		return nil
	}
	var item LayoutElementHashMapItem = LayoutElementHashMapItem{ElementId: elementId, LayoutElement: layoutElement, NextIndex: -1, Generation: context.generation + 1}
	var hashBucket uint32 = elementId.Id % uint32(context.layoutElementsHashMap.Capacity)
	var hashItemPrevious int32 = -1
	var hashItemIndex int32 = *(*int32)(unsafe.Add(unsafe.Pointer(context.layoutElementsHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket)))
	for hashItemIndex != -1 {
		var hashItem *LayoutElementHashMapItem = __LayoutElementHashMapItemArray_Get(&context.layoutElementsHashMapInternal, hashItemIndex)
		if hashItem.ElementId.Id == elementId.Id {
			item.NextIndex = hashItem.NextIndex
			if hashItem.Generation <= context.generation {
				hashItem.ElementId = elementId
				hashItem.Generation = context.generation + 1
				hashItem.LayoutElement = layoutElement
				hashItem.DebugData.Collision = false
				hashItem.OnHoverFunction = nil
				hashItem.HoverFunctionUserData = 0
			} else {
				context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_DUPLICATE_ID, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("An element with this ID was already previously declared during this layout.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("An element with this ID was already previously declared during this layout.")}, UserData: context.errorHandler.UserData})
				if context.debugModeEnabled {
					hashItem.DebugData.Collision = true
				}
			}
			return hashItem
		}
		hashItemPrevious = hashItemIndex
		hashItemIndex = hashItem.NextIndex
	}
	var hashItem *LayoutElementHashMapItem = __LayoutElementHashMapItemArray_Add(&context.layoutElementsHashMapInternal, item)
	hashItem.DebugData = __DebugElementDataArray_Add(&context.debugElementData, __DebugElementData{Collision: false})
	if hashItemPrevious != -1 {
		__LayoutElementHashMapItemArray_Get(&context.layoutElementsHashMapInternal, hashItemPrevious).NextIndex = context.layoutElementsHashMapInternal.Length - 1
	} else {
		*(*int32)(unsafe.Add(unsafe.Pointer(context.layoutElementsHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket))) = context.layoutElementsHashMapInternal.Length - 1
	}
	return hashItem
}

func __GetHashMapItem(id uint32) *LayoutElementHashMapItem {
	var (
		context      *Context = GetCurrentContext()
		hashBucket   uint32   = id % uint32(context.layoutElementsHashMap.Capacity)
		elementIndex int32    = *(*int32)(unsafe.Add(unsafe.Pointer(context.layoutElementsHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(hashBucket)))
	)
	for elementIndex != -1 {
		var hashEntry *LayoutElementHashMapItem = __LayoutElementHashMapItemArray_Get(&context.layoutElementsHashMapInternal, elementIndex)
		if hashEntry.ElementId.Id == id {
			return hashEntry
		}
		elementIndex = hashEntry.NextIndex
	}
	return &LayoutElementHashMapItem_DEFAULT
}

func __GenerateIdForAnonymousElement(openLayoutElement *LayoutElement) ElementId {
	var (
		context       *Context       = GetCurrentContext()
		parentElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-2))
		elementId     ElementId      = __HashNumber(uint32(parentElement.ChildrenOrTextContent.Children.Length), parentElement.Id)
	)
	openLayoutElement.Id = elementId.Id
	__AddHashMapItem(elementId, openLayoutElement)
	__StringArray_Add(&context.layoutElementIdStrings, elementId.StringId)
	return elementId
}

func __ElementHasConfig(layoutElement *LayoutElement, type_ __ElementConfigType) bool {
	for i := int32(0); i < layoutElement.ElementConfigs.Length; i++ {
		if __ElementConfigArraySlice_Get(&layoutElement.ElementConfigs, i).Type == type_ {
			return true
		}
	}
	return false
}

func __UpdateAspectRatioBox(layoutElement *LayoutElement) {
	for j := int32(0); j < layoutElement.ElementConfigs.Length; j++ {
		var config *ElementConfig = __ElementConfigArraySlice_Get(&layoutElement.ElementConfigs, j)
		if config.Type == __ELEMENT_CONFIG_TYPE_ASPECT {
			var aspectConfig *AspectRatioElementConfig = config.Config.AspectRatioElementConfig
			if aspectConfig.AspectRatio == 0 {
				break
			}
			if layoutElement.Dimensions.Width == 0 && layoutElement.Dimensions.Height != 0 {
				layoutElement.Dimensions.Width = layoutElement.Dimensions.Height * aspectConfig.AspectRatio
			} else if layoutElement.Dimensions.Width != 0 && layoutElement.Dimensions.Height == 0 {
				layoutElement.Dimensions.Height = layoutElement.Dimensions.Width * (1 / aspectConfig.AspectRatio)
			}
			break
		}
	}
}

func __CloseElement() {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return
	}
	var openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	var layoutConfig *LayoutConfig = openLayoutElement.LayoutConfig
	if layoutConfig == nil {
		openLayoutElement.LayoutConfig = &LayoutConfig_DEFAULT
		layoutConfig = &LayoutConfig_DEFAULT
	}
	var elementHasClipHorizontal bool = false
	var elementHasClipVertical bool = false
	for i := int32(0); i < openLayoutElement.ElementConfigs.Length; i++ {
		var config *ElementConfig = __ElementConfigArraySlice_Get(&openLayoutElement.ElementConfigs, i)
		if config.Type == __ELEMENT_CONFIG_TYPE_CLIP {
			elementHasClipHorizontal = config.Config.ClipElementConfig.Horizontal
			elementHasClipVertical = config.Config.ClipElementConfig.Vertical
			context.openClipElementStack.Length--
			break
		} else if config.Type == __ELEMENT_CONFIG_TYPE_FLOATING {
			context.openClipElementStack.Length--
		}
	}
	var leftRightPadding float32 = float32(int32(layoutConfig.Padding.Left) + int32(layoutConfig.Padding.Right))
	var topBottomPadding float32 = float32(int32(layoutConfig.Padding.Top) + int32(layoutConfig.Padding.Bottom))
	openLayoutElement.ChildrenOrTextContent.Children.Elements = (*int32)(unsafe.Add(unsafe.Pointer(context.layoutElementChildren.InternalArray), unsafe.Sizeof(int32(0))*uintptr(context.layoutElementChildren.Length)))
	if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
		openLayoutElement.Dimensions.Width = leftRightPadding
		openLayoutElement.MinDimensions.Width = leftRightPadding
		for i := int32(0); i < int32(openLayoutElement.ChildrenOrTextContent.Children.Length); i++ {
			var (
				childIndex int32          = __int32_tArray_GetValue(&context.layoutElementChildrenBuffer, context.layoutElementChildrenBuffer.Length-int32(openLayoutElement.ChildrenOrTextContent.Children.Length)+i)
				child      *LayoutElement = LayoutElementArray_Get(&context.layoutElements, childIndex)
			)
			openLayoutElement.Dimensions.Width += child.Dimensions.Width
			if openLayoutElement.Dimensions.Height > (child.Dimensions.Height + topBottomPadding) {
				/* (004) */
			} else {
				openLayoutElement.Dimensions.Height = child.Dimensions.Height + topBottomPadding
			}
			if !elementHasClipHorizontal {
				openLayoutElement.MinDimensions.Width += child.MinDimensions.Width
			}
			if !elementHasClipVertical {
				if openLayoutElement.MinDimensions.Height > (child.MinDimensions.Height + topBottomPadding) {
					/* (005) */
				} else {
					openLayoutElement.MinDimensions.Height = child.MinDimensions.Height + topBottomPadding
				}
			}
			__int32_tArray_Add(&context.layoutElementChildren, childIndex)
		}
		var childGap float32 = float32((func() int32 {
			if (int32(openLayoutElement.ChildrenOrTextContent.Children.Length) - 1) > 0 {
				return int32(openLayoutElement.ChildrenOrTextContent.Children.Length) - 1
			}
			return 0
		}()) * int32(layoutConfig.ChildGap))
		openLayoutElement.Dimensions.Width += childGap
		if !elementHasClipHorizontal {
			openLayoutElement.MinDimensions.Width += childGap
		}
	} else if layoutConfig.LayoutDirection == TOP_TO_BOTTOM {
		openLayoutElement.Dimensions.Height = topBottomPadding
		openLayoutElement.MinDimensions.Height = topBottomPadding
		for i := int32(0); i < int32(openLayoutElement.ChildrenOrTextContent.Children.Length); i++ {
			var (
				childIndex int32          = __int32_tArray_GetValue(&context.layoutElementChildrenBuffer, context.layoutElementChildrenBuffer.Length-int32(openLayoutElement.ChildrenOrTextContent.Children.Length)+i)
				child      *LayoutElement = LayoutElementArray_Get(&context.layoutElements, childIndex)
			)
			openLayoutElement.Dimensions.Height += child.Dimensions.Height
			if openLayoutElement.Dimensions.Width > (child.Dimensions.Width + leftRightPadding) {
				/* (006) */
			} else {
				openLayoutElement.Dimensions.Width = child.Dimensions.Width + leftRightPadding
			}
			if !elementHasClipVertical {
				openLayoutElement.MinDimensions.Height += child.MinDimensions.Height
			}
			if !elementHasClipHorizontal {
				if openLayoutElement.MinDimensions.Width > (child.MinDimensions.Width + leftRightPadding) {
					/* (007) */
				} else {
					openLayoutElement.MinDimensions.Width = child.MinDimensions.Width + leftRightPadding
				}
			}
			__int32_tArray_Add(&context.layoutElementChildren, childIndex)
		}
		var childGap float32 = float32((func() int32 {
			if (int32(openLayoutElement.ChildrenOrTextContent.Children.Length) - 1) > 0 {
				return int32(openLayoutElement.ChildrenOrTextContent.Children.Length) - 1
			}
			return 0
		}()) * int32(layoutConfig.ChildGap))
		openLayoutElement.Dimensions.Height += childGap
		if !elementHasClipVertical {
			openLayoutElement.MinDimensions.Height += childGap
		}
	}
	context.layoutElementChildrenBuffer.Length -= int32(openLayoutElement.ChildrenOrTextContent.Children.Length)
	if layoutConfig.Sizing.Width.Type != __SIZING_TYPE_PERCENT {
		if layoutConfig.Sizing.Width.Size.MinMax.Max <= 0 {
			layoutConfig.Sizing.Width.Size.MinMax.Max = __MAXFLOAT
		}
		if (func() float32 {
			if openLayoutElement.Dimensions.Width > layoutConfig.Sizing.Width.Size.MinMax.Min {
				return openLayoutElement.Dimensions.Width
			}
			return layoutConfig.Sizing.Width.Size.MinMax.Min
		}()) < layoutConfig.Sizing.Width.Size.MinMax.Max {
			if openLayoutElement.Dimensions.Width > layoutConfig.Sizing.Width.Size.MinMax.Min {
				/* (006) */
			} else {
				openLayoutElement.Dimensions.Width = layoutConfig.Sizing.Width.Size.MinMax.Min
			}
		} else {
			openLayoutElement.Dimensions.Width = layoutConfig.Sizing.Width.Size.MinMax.Max
		}
		if (func() float32 {
			if openLayoutElement.MinDimensions.Width > layoutConfig.Sizing.Width.Size.MinMax.Min {
				return openLayoutElement.MinDimensions.Width
			}
			return layoutConfig.Sizing.Width.Size.MinMax.Min
		}()) < layoutConfig.Sizing.Width.Size.MinMax.Max {
			if openLayoutElement.MinDimensions.Width > layoutConfig.Sizing.Width.Size.MinMax.Min {
				/* (007) */
			} else {
				openLayoutElement.MinDimensions.Width = layoutConfig.Sizing.Width.Size.MinMax.Min
			}
		} else {
			openLayoutElement.MinDimensions.Width = layoutConfig.Sizing.Width.Size.MinMax.Max
		}
	} else {
		openLayoutElement.Dimensions.Width = 0
	}
	if layoutConfig.Sizing.Height.Type != __SIZING_TYPE_PERCENT {
		if layoutConfig.Sizing.Height.Size.MinMax.Max <= 0 {
			layoutConfig.Sizing.Height.Size.MinMax.Max = __MAXFLOAT
		}
		if (func() float32 {
			if openLayoutElement.Dimensions.Height > layoutConfig.Sizing.Height.Size.MinMax.Min {
				return openLayoutElement.Dimensions.Height
			}
			return layoutConfig.Sizing.Height.Size.MinMax.Min
		}()) < layoutConfig.Sizing.Height.Size.MinMax.Max {
			if openLayoutElement.Dimensions.Height > layoutConfig.Sizing.Height.Size.MinMax.Min {
				/* (004) */
			} else {
				openLayoutElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Min
			}
		} else {
			openLayoutElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Max
		}
		if (func() float32 {
			if openLayoutElement.MinDimensions.Height > layoutConfig.Sizing.Height.Size.MinMax.Min {
				return openLayoutElement.MinDimensions.Height
			}
			return layoutConfig.Sizing.Height.Size.MinMax.Min
		}()) < layoutConfig.Sizing.Height.Size.MinMax.Max {
			if openLayoutElement.MinDimensions.Height > layoutConfig.Sizing.Height.Size.MinMax.Min {
				/* (005) */
			} else {
				openLayoutElement.MinDimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Min
			}
		} else {
			openLayoutElement.MinDimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Max
		}
	} else {
		openLayoutElement.Dimensions.Height = 0
	}
	__UpdateAspectRatioBox(openLayoutElement)
	var elementIsFloating bool = __ElementHasConfig(openLayoutElement, __ELEMENT_CONFIG_TYPE_FLOATING)
	var closingElementIndex int32 = __int32_tArray_RemoveSwapback(&context.openLayoutElementStack, context.openLayoutElementStack.Length-1)
	openLayoutElement = __GetOpenLayoutElement()
	if !elementIsFloating && context.openLayoutElementStack.Length > 1 {
		openLayoutElement.ChildrenOrTextContent.Children.Length++
		__int32_tArray_Add(&context.layoutElementChildrenBuffer, closingElementIndex)
	}
}

func __MemCmp(s1 *byte, s2 *byte, length int32) bool {
	for i := int32(0); i < length; i++ {
		if *(*byte)(unsafe.Add(unsafe.Pointer(s1), i)) != *(*byte)(unsafe.Add(unsafe.Pointer(s2), i)) {
			return false
		}
	}
	return true
}

func __OpenElement() {
	var context *Context = GetCurrentContext()
	if context.layoutElements.Length == context.layoutElements.Capacity-1 || context.booleanWarnings.MaxElementsExceeded {
		context.booleanWarnings.MaxElementsExceeded = true
		return
	}
	var layoutElement LayoutElement = LayoutElement{}
	var openLayoutElement *LayoutElement = LayoutElementArray_Add(&context.layoutElements, layoutElement)
	__int32_tArray_Add(&context.openLayoutElementStack, context.layoutElements.Length-1)
	__GenerateIdForAnonymousElement(openLayoutElement)
	if context.openClipElementStack.Length > 0 {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, __int32_tArray_GetValue(&context.openClipElementStack, context.openClipElementStack.Length-1))
	} else {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, 0)
	}
}

func __OpenElementWithId(elementId ElementId) {
	var context *Context = GetCurrentContext()
	if context.layoutElements.Length == context.layoutElements.Capacity-1 || context.booleanWarnings.MaxElementsExceeded {
		context.booleanWarnings.MaxElementsExceeded = true
		return
	}
	var layoutElement LayoutElement = LayoutElement{}
	layoutElement.Id = elementId.Id
	var openLayoutElement *LayoutElement = LayoutElementArray_Add(&context.layoutElements, layoutElement)
	__int32_tArray_Add(&context.openLayoutElementStack, context.layoutElements.Length-1)
	__AddHashMapItem(elementId, openLayoutElement)
	__StringArray_Add(&context.layoutElementIdStrings, elementId.StringId)
	if context.openClipElementStack.Length > 0 {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, __int32_tArray_GetValue(&context.openClipElementStack, context.openClipElementStack.Length-1))
	} else {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, 0)
	}
}

func __OpenTextElement(text String, textConfig *TextElementConfig) {
	var context *Context = GetCurrentContext()
	if context.layoutElements.Length == context.layoutElements.Capacity-1 || context.booleanWarnings.MaxElementsExceeded {
		context.booleanWarnings.MaxElementsExceeded = true
		return
	}
	var parentElement *LayoutElement = __GetOpenLayoutElement()
	var layoutElement LayoutElement = LayoutElement{}
	var textElement *LayoutElement = LayoutElementArray_Add(&context.layoutElements, layoutElement)
	if context.openClipElementStack.Length > 0 {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, __int32_tArray_GetValue(&context.openClipElementStack, context.openClipElementStack.Length-1))
	} else {
		__int32_tArray_Set(&context.layoutElementClipElementIds, context.layoutElements.Length-1, 0)
	}
	__int32_tArray_Add(&context.layoutElementChildrenBuffer, context.layoutElements.Length-1)
	var textMeasured *__MeasureTextCacheItem = __MeasureTextCached(&text, textConfig)
	var elementId ElementId = __HashNumber(uint32(parentElement.ChildrenOrTextContent.Children.Length), parentElement.Id)
	textElement.Id = elementId.Id
	__AddHashMapItem(elementId, textElement)
	__StringArray_Add(&context.layoutElementIdStrings, elementId.StringId)
	var textDimensions Dimensions = Dimensions{Width: textMeasured.UnwrappedDimensions.Width, Height: func() float32 {
		if int32(textConfig.LineHeight) > 0 {
			return float32(textConfig.LineHeight)
		}
		return textMeasured.UnwrappedDimensions.Height
	}()}
	textElement.Dimensions = textDimensions
	textElement.MinDimensions = Dimensions{Width: textMeasured.MinWidth, Height: textDimensions.Height}
	textElement.ChildrenOrTextContent.TextElementData = __TextElementDataArray_Add(&context.textElementData, __TextElementData{Text: text, PreferredDimensions: textMeasured.UnwrappedDimensions, ElementIndex: context.layoutElements.Length - 1})
	textElement.ElementConfigs = __ElementConfigArraySlice{Length: 1, InternalArray: __ElementConfigArray_Add(&context.elementConfigs, ElementConfig{Type: __ELEMENT_CONFIG_TYPE_TEXT, Config: ElementConfigUnion{TextElementConfig: textConfig}})}
	textElement.LayoutConfig = &LAYOUT_DEFAULT
	parentElement.ChildrenOrTextContent.Children.Length++
}

func __ConfigureOpenElementPtr(declaration *ElementDeclaration) {
	var (
		context           *Context       = GetCurrentContext()
		openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	)
	openLayoutElement.LayoutConfig = __StoreLayoutConfig(declaration.Layout)
	if declaration.Layout.Sizing.Width.Type == __SIZING_TYPE_PERCENT && declaration.Layout.Sizing.Width.Size.Percent > 1 || declaration.Layout.Sizing.Height.Type == __SIZING_TYPE_PERCENT && declaration.Layout.Sizing.Height.Size.Percent > 1 {
		context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_PERCENTAGE_OVER_1, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("An element was configured with SIZING_PERCENT, but the provided percentage value was over 1.0. Clay expects a value between 0 and 1, i.e. 20% is 0.2.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("An element was configured with SIZING_PERCENT, but the provided percentage value was over 1.0. Clay expects a value between 0 and 1, i.e. 20% is 0.2.")}, UserData: context.errorHandler.UserData})
	}
	openLayoutElement.ElementConfigs.InternalArray = (*ElementConfig)(unsafe.Add(unsafe.Pointer(context.elementConfigs.InternalArray), unsafe.Sizeof(ElementConfig{})*uintptr(context.elementConfigs.Length)))
	var sharedConfig *SharedElementConfig = nil
	if declaration.BackgroundColor.A > 0 {
		sharedConfig = __StoreSharedElementConfig(SharedElementConfig{BackgroundColor: declaration.BackgroundColor})
		__AttachElementConfig(ElementConfigUnion{SharedElementConfig: sharedConfig}, __ELEMENT_CONFIG_TYPE_SHARED)
	}
	if !__MemCmp((*byte)(unsafe.Pointer(&declaration.CornerRadius)), (*byte)(unsafe.Pointer(&__CornerRadius_DEFAULT)), int32(uint32(unsafe.Sizeof(CornerRadius{})))) {
		if sharedConfig != nil {
			sharedConfig.CornerRadius = declaration.CornerRadius
		} else {
			sharedConfig = __StoreSharedElementConfig(SharedElementConfig{CornerRadius: declaration.CornerRadius})
			__AttachElementConfig(ElementConfigUnion{SharedElementConfig: sharedConfig}, __ELEMENT_CONFIG_TYPE_SHARED)
		}
	}
	if declaration.UserData != nil {
		if sharedConfig != nil {
			sharedConfig.UserData = declaration.UserData
		} else {
			sharedConfig = __StoreSharedElementConfig(SharedElementConfig{UserData: declaration.UserData})
			__AttachElementConfig(ElementConfigUnion{SharedElementConfig: sharedConfig}, __ELEMENT_CONFIG_TYPE_SHARED)
		}
	}
	if declaration.Image.ImageData != nil {
		__AttachElementConfig(ElementConfigUnion{ImageElementConfig: __StoreImageElementConfig(declaration.Image)}, __ELEMENT_CONFIG_TYPE_IMAGE)
	}
	if declaration.AspectRatio.AspectRatio > 0 {
		__AttachElementConfig(ElementConfigUnion{AspectRatioElementConfig: __StoreAspectRatioElementConfig(declaration.AspectRatio)}, __ELEMENT_CONFIG_TYPE_ASPECT)
		__int32_tArray_Add(&context.AspectRatioElementIndexes, context.layoutElements.Length-1)
	}
	if declaration.Floating.AttachTo != ATTACH_TO_NONE {
		var (
			floatingConfig     FloatingElementConfig = declaration.Floating
			hierarchicalParent *LayoutElement        = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-2))
		)
		if hierarchicalParent != nil {
			var clipElementId uint32 = 0
			if declaration.Floating.AttachTo == ATTACH_TO_PARENT {
				floatingConfig.ParentId = hierarchicalParent.Id
				if context.openClipElementStack.Length > 0 {
					clipElementId = uint32(__int32_tArray_GetValue(&context.openClipElementStack, context.openClipElementStack.Length-1))
				}
			} else if declaration.Floating.AttachTo == ATTACH_TO_ELEMENT_WITH_ID {
				var parentItem *LayoutElementHashMapItem = __GetHashMapItem(floatingConfig.ParentId)
				if parentItem == &LayoutElementHashMapItem_DEFAULT {
					context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_FLOATING_CONTAINER_PARENT_NOT_FOUND, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("A floating element was declared with a parentId, but no element with that ID was found.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("A floating element was declared with a parentId, but no element with that ID was found.")}, UserData: context.errorHandler.UserData})
				} else {
					clipElementId = uint32(__int32_tArray_GetValue(&context.layoutElementClipElementIds, int32(int64((uintptr(unsafe.Pointer(parentItem.LayoutElement))-uintptr(unsafe.Pointer(context.layoutElements.InternalArray)))/unsafe.Sizeof(LayoutElement{})))))
				}
			} else if declaration.Floating.AttachTo == ATTACH_TO_ROOT {
				floatingConfig.ParentId = __HashString(String{IsStaticallyAllocated: true, Length: int32(((len("__RootContainer") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("__RootContainer")}, 0).Id
			}
			if declaration.Floating.ClipTo == CLIP_TO_NONE {
				clipElementId = 0
			}
			var currentElementIndex int32 = __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-1)
			__int32_tArray_Set(&context.layoutElementClipElementIds, currentElementIndex, int32(clipElementId))
			__int32_tArray_Add(&context.openClipElementStack, int32(clipElementId))
			__LayoutElementTreeRootArray_Add(&context.layoutElementTreeRoots, __LayoutElementTreeRoot{LayoutElementIndex: __int32_tArray_GetValue(&context.openLayoutElementStack, context.openLayoutElementStack.Length-1), ParentId: floatingConfig.ParentId, ClipElementId: clipElementId, ZIndex: floatingConfig.ZIndex})
			__AttachElementConfig(ElementConfigUnion{FloatingElementConfig: __StoreFloatingElementConfig(floatingConfig)}, __ELEMENT_CONFIG_TYPE_FLOATING)
		}
	}
	if declaration.Custom.CustomData != nil {
		__AttachElementConfig(ElementConfigUnion{CustomElementConfig: __StoreCustomElementConfig(declaration.Custom)}, __ELEMENT_CONFIG_TYPE_CUSTOM)
	}
	if declaration.Clip.Horizontal || declaration.Clip.Vertical {
		__AttachElementConfig(ElementConfigUnion{ClipElementConfig: __StoreClipElementConfig(declaration.Clip)}, __ELEMENT_CONFIG_TYPE_CLIP)
		__int32_tArray_Add(&context.openClipElementStack, int32(openLayoutElement.Id))
		var scrollOffset *__ScrollContainerDataInternal = (*__ScrollContainerDataInternal)(nil)
		for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
			var mapping *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
			if openLayoutElement.Id == mapping.ElementId {
				scrollOffset = mapping
				scrollOffset.LayoutElement = openLayoutElement
				scrollOffset.OpenThisFrame = true
			}
		}
		if scrollOffset == nil {
			scrollOffset = __ScrollContainerDataInternalArray_Add(&context.scrollContainerDatas, __ScrollContainerDataInternal{LayoutElement: openLayoutElement, ScrollOrigin: Vector2{X: -1, Y: -1}, ElementId: openLayoutElement.Id, OpenThisFrame: true})
		}
		if context.externalScrollHandlingEnabled {
			scrollOffset.ScrollPosition = __QueryScrollOffset(scrollOffset.ElementId, context.queryScrollOffsetUserData.(unsafe.Pointer))
		}
	}
	if !__MemCmp((*byte)(unsafe.Pointer(&declaration.Border.Width)), (*byte)(unsafe.Pointer(&__BorderWidth_DEFAULT)), int32(uint32(unsafe.Sizeof(BorderWidth{})))) {
		__AttachElementConfig(ElementConfigUnion{BorderElementConfig: __StoreBorderElementConfig(declaration.Border)}, __ELEMENT_CONFIG_TYPE_BORDER)
	}
}

func __ConfigureOpenElement(declaration ElementDeclaration) {
	__ConfigureOpenElementPtr(&declaration)
}

func __InitializeEphemeralMemory(context *Context) {
	var (
		maxElementCount int32  = context.maxElementCount
		arena           *Arena = &context.internalArena
	)
	arena.NextAllocation = context.arenaResetOffset
	context.layoutElementChildrenBuffer = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElements = LayoutElementArray_Allocate_Arena(maxElementCount, arena)
	context.warnings = __WarningArray_Allocate_Arena(100, arena)
	context.layoutConfigs = __LayoutConfigArray_Allocate_Arena(maxElementCount, arena)
	context.elementConfigs = __ElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.textElementConfigs = __TextElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.AspectRatioElementConfigs = __AspectRatioElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.imageElementConfigs = __ImageElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.floatingElementConfigs = __FloatingElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.ClipElementConfigs = __ClipElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.customElementConfigs = __CustomElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.borderElementConfigs = __BorderElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.sharedElementConfigs = __SharedElementConfigArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementIdStrings = __StringArray_Allocate_Arena(maxElementCount, arena)
	context.wrappedTextLines = __WrappedTextLineArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementTreeNodeArray1 = __LayoutElementTreeNodeArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementTreeRoots = __LayoutElementTreeRootArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementChildren = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.openLayoutElementStack = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.textElementData = __TextElementDataArray_Allocate_Arena(maxElementCount, arena)
	context.AspectRatioElementIndexes = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.renderCommands = RenderCommandArray_Allocate_Arena(maxElementCount, arena)
	context.treeNodeVisited = __boolArray_Allocate_Arena(maxElementCount, arena)
	context.treeNodeVisited.Length = context.treeNodeVisited.Capacity
	context.openClipElementStack = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.reusableElementIndexBuffer = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementClipElementIds = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.dynamicStringData = __charArray_Allocate_Arena(maxElementCount, arena)
}

func __InitializePersistentMemory(context *Context) {
	var (
		maxElementCount              int32  = context.maxElementCount
		maxMeasureTextCacheWordCount int32  = context.maxMeasureTextCacheWordCount
		arena                        *Arena = &context.internalArena
	)
	context.scrollContainerDatas = __ScrollContainerDataInternalArray_Allocate_Arena(100, arena)
	context.layoutElementsHashMapInternal = __LayoutElementHashMapItemArray_Allocate_Arena(maxElementCount, arena)
	context.layoutElementsHashMap = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.measureTextHashMapInternal = __MeasureTextCacheItemArray_Allocate_Arena(maxElementCount, arena)
	context.measureTextHashMapInternalFreeList = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.measuredWordsFreeList = __int32_tArray_Allocate_Arena(maxMeasureTextCacheWordCount, arena)
	context.measureTextHashMap = __int32_tArray_Allocate_Arena(maxElementCount, arena)
	context.measuredWords = __MeasuredWordArray_Allocate_Arena(maxMeasureTextCacheWordCount, arena)
	context.pointerOverIds = ElementIdArray_Allocate_Arena(maxElementCount, arena)
	context.debugElementData = __DebugElementDataArray_Allocate_Arena(maxElementCount, arena)
	context.arenaResetOffset = arena.NextAllocation
}

var __EPSILON float32 = 0.01

func __FloatEqual(left float32, right float32) bool {
	var subtracted float32 = left - right
	return subtracted < __EPSILON && subtracted > -__EPSILON
}

func __SizeContainersAlongAxis(xAxis bool) {
	var (
		context                  *Context       = GetCurrentContext()
		bfsBuffer                __int32_tArray = context.layoutElementChildrenBuffer
		resizableContainerBuffer __int32_tArray = context.openLayoutElementStack
	)
	for rootIndex := int32(0); rootIndex < context.layoutElementTreeRoots.Length; rootIndex++ {
		bfsBuffer.Length = 0
		var root *__LayoutElementTreeRoot = __LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, rootIndex)
		var rootElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, root.LayoutElementIndex)
		__int32_tArray_Add(&bfsBuffer, root.LayoutElementIndex)
		if __ElementHasConfig(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING) {
			var (
				floatingElementConfig *FloatingElementConfig    = __FindElementConfigWithType(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING).FloatingElementConfig
				parentItem            *LayoutElementHashMapItem = __GetHashMapItem(floatingElementConfig.ParentId)
			)
			if parentItem != nil && parentItem != &LayoutElementHashMapItem_DEFAULT {
				var parentLayoutElement *LayoutElement = parentItem.LayoutElement
				switch rootElement.LayoutConfig.Sizing.Width.Type {
				case __SIZING_TYPE_GROW:
					rootElement.Dimensions.Width = parentLayoutElement.Dimensions.Width
				case __SIZING_TYPE_PERCENT:
					rootElement.Dimensions.Width = parentLayoutElement.Dimensions.Width * rootElement.LayoutConfig.Sizing.Width.Size.Percent
				default:
				}
				switch rootElement.LayoutConfig.Sizing.Height.Type {
				case __SIZING_TYPE_GROW:
					rootElement.Dimensions.Height = parentLayoutElement.Dimensions.Height
				case __SIZING_TYPE_PERCENT:
					rootElement.Dimensions.Height = parentLayoutElement.Dimensions.Height * rootElement.LayoutConfig.Sizing.Height.Size.Percent
				default:
				}
			}
		}
		if rootElement.LayoutConfig.Sizing.Width.Type != __SIZING_TYPE_PERCENT {
			if (func() float32 {
				if rootElement.Dimensions.Width > rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Min {
					return rootElement.Dimensions.Width
				}
				return rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Min
			}()) < rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Max {
				if rootElement.Dimensions.Width > rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Min {
					/* (008) */
				} else {
					rootElement.Dimensions.Width = rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Min
				}
			} else {
				rootElement.Dimensions.Width = rootElement.LayoutConfig.Sizing.Width.Size.MinMax.Max
			}
		}
		if rootElement.LayoutConfig.Sizing.Height.Type != __SIZING_TYPE_PERCENT {
			if (func() float32 {
				if rootElement.Dimensions.Height > rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Min {
					return rootElement.Dimensions.Height
				}
				return rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Min
			}()) < rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Max {
				if rootElement.Dimensions.Height > rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Min {
					/* (009) */
				} else {
					rootElement.Dimensions.Height = rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Min
				}
			} else {
				rootElement.Dimensions.Height = rootElement.LayoutConfig.Sizing.Height.Size.MinMax.Max
			}
		}
		for i := int32(0); i < bfsBuffer.Length; i++ {
			var (
				parentIndex        int32          = __int32_tArray_GetValue(&bfsBuffer, i)
				parent             *LayoutElement = LayoutElementArray_Get(&context.layoutElements, parentIndex)
				parentStyleConfig  *LayoutConfig  = parent.LayoutConfig
				growContainerCount int32          = 0
				parentSize         float32
			)
			if xAxis {
				parentSize = parent.Dimensions.Width
			} else {
				parentSize = parent.Dimensions.Height
			}
			var parentPadding float32 = float32(func() int32 {
				if xAxis {
					return int32(parent.LayoutConfig.Padding.Left) + int32(parent.LayoutConfig.Padding.Right)
				}
				return int32(parent.LayoutConfig.Padding.Top) + int32(parent.LayoutConfig.Padding.Bottom)
			}())
			var innerContentSize float32 = 0
			var totalPaddingAndChildGaps float32 = parentPadding
			var sizingAlongAxis bool = xAxis && parentStyleConfig.LayoutDirection == LEFT_TO_RIGHT || !xAxis && parentStyleConfig.LayoutDirection == TOP_TO_BOTTOM
			resizableContainerBuffer.Length = 0
			var parentChildGap float32 = float32(parentStyleConfig.ChildGap)
			for childOffset := int32(0); childOffset < int32(parent.ChildrenOrTextContent.Children.Length); childOffset++ {
				var (
					childElementIndex int32          = *(*int32)(unsafe.Add(unsafe.Pointer(parent.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(childOffset)))
					childElement      *LayoutElement = LayoutElementArray_Get(&context.layoutElements, childElementIndex)
					childSizing       SizingAxis
				)
				if xAxis {
					childSizing = childElement.LayoutConfig.Sizing.Width
				} else {
					childSizing = childElement.LayoutConfig.Sizing.Height
				}
				var childSize float32
				if xAxis {
					childSize = childElement.Dimensions.Width
				} else {
					childSize = childElement.Dimensions.Height
				}
				if !__ElementHasConfig(childElement, __ELEMENT_CONFIG_TYPE_TEXT) && int32(childElement.ChildrenOrTextContent.Children.Length) > 0 {
					__int32_tArray_Add(&bfsBuffer, childElementIndex)
				}
				if childSizing.Type != __SIZING_TYPE_PERCENT && childSizing.Type != __SIZING_TYPE_FIXED && (!__ElementHasConfig(childElement, __ELEMENT_CONFIG_TYPE_TEXT) || __FindElementConfigWithType(childElement, __ELEMENT_CONFIG_TYPE_TEXT).TextElementConfig.WrapMode == TEXT_WRAP_WORDS) {
					__int32_tArray_Add(&resizableContainerBuffer, childElementIndex)
				}
				if sizingAlongAxis {
					if childSizing.Type == __SIZING_TYPE_PERCENT {
						innerContentSize += 0
					} else {
						innerContentSize += childSize
					}
					if childSizing.Type == __SIZING_TYPE_GROW {
						growContainerCount++
					}
					if childOffset > 0 {
						innerContentSize += parentChildGap
						totalPaddingAndChildGaps += parentChildGap
					}
				} else {
					if childSize > innerContentSize {
						innerContentSize = childSize
					} else {
						/* (010) */
					}
				}
			}
			for childOffset := int32(0); childOffset < int32(parent.ChildrenOrTextContent.Children.Length); childOffset++ {
				var (
					childElementIndex int32          = *(*int32)(unsafe.Add(unsafe.Pointer(parent.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(childOffset)))
					childElement      *LayoutElement = LayoutElementArray_Get(&context.layoutElements, childElementIndex)
					childSizing       SizingAxis
				)
				if xAxis {
					childSizing = childElement.LayoutConfig.Sizing.Width
				} else {
					childSizing = childElement.LayoutConfig.Sizing.Height
				}
				var childSize *float32
				if xAxis {
					childSize = &childElement.Dimensions.Width
				} else {
					childSize = &childElement.Dimensions.Height
				}
				if childSizing.Type == __SIZING_TYPE_PERCENT {
					*childSize = (parentSize - totalPaddingAndChildGaps) * childSizing.Size.Percent
					if sizingAlongAxis {
						innerContentSize += *childSize
					}
					__UpdateAspectRatioBox(childElement)
				}
			}
			if sizingAlongAxis {
				var sizeToDistribute float32 = parentSize - parentPadding - innerContentSize
				if sizeToDistribute < 0 {
					var clipElementConfig *ClipElementConfig = __FindElementConfigWithType(parent, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
					if clipElementConfig != nil {
						if xAxis && clipElementConfig.Horizontal || !xAxis && clipElementConfig.Vertical {
							continue
						}
					}
					for sizeToDistribute < -__EPSILON && resizableContainerBuffer.Length > 0 {
						var (
							largest       float32 = 0
							secondLargest float32 = 0
							widthToAdd    float32 = sizeToDistribute
						)
						for childIndex := int32(0); childIndex < resizableContainerBuffer.Length; childIndex++ {
							var (
								child     *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childIndex))
								childSize float32
							)
							if xAxis {
								childSize = child.Dimensions.Width
							} else {
								childSize = child.Dimensions.Height
							}
							if __FloatEqual(childSize, largest) {
								continue
							}
							if childSize > largest {
								secondLargest = largest
								largest = childSize
							}
							if childSize < largest {
								if secondLargest > childSize {
									/* (011) */
								} else {
									secondLargest = childSize
								}
								widthToAdd = secondLargest - largest
							}
						}
						if widthToAdd > (sizeToDistribute / float32(resizableContainerBuffer.Length)) {
							/* (012) */
						} else {
							widthToAdd = sizeToDistribute / float32(resizableContainerBuffer.Length)
						}
						for childIndex := int32(0); childIndex < resizableContainerBuffer.Length; childIndex++ {
							var (
								child     *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childIndex))
								childSize *float32
							)
							if xAxis {
								childSize = &child.Dimensions.Width
							} else {
								childSize = &child.Dimensions.Height
							}
							var minSize float32
							if xAxis {
								minSize = child.MinDimensions.Width
							} else {
								minSize = child.MinDimensions.Height
							}
							var previousWidth float32 = *childSize
							if __FloatEqual(*childSize, largest) {
								*childSize += widthToAdd
								if *childSize <= minSize {
									*childSize = minSize
									__int32_tArray_RemoveSwapback(&resizableContainerBuffer, func() int32 {
										p_ := &childIndex
										x := *p_
										*p_--
										return x
									}())
								}
								sizeToDistribute -= *childSize - previousWidth
							}
						}
					}
				} else if sizeToDistribute > 0 && growContainerCount > 0 {
					for childIndex := int32(0); childIndex < resizableContainerBuffer.Length; childIndex++ {
						var (
							child       *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childIndex))
							childSizing __SizingType
						)
						if xAxis {
							childSizing = child.LayoutConfig.Sizing.Width.Type
						} else {
							childSizing = child.LayoutConfig.Sizing.Height.Type
						}
						if childSizing != __SIZING_TYPE_GROW {
							__int32_tArray_RemoveSwapback(&resizableContainerBuffer, func() int32 {
								p_ := &childIndex
								x := *p_
								*p_--
								return x
							}())
						}
					}
					for sizeToDistribute > __EPSILON && resizableContainerBuffer.Length > 0 {
						var (
							smallest       float32 = __MAXFLOAT
							secondSmallest float32 = __MAXFLOAT
							widthToAdd     float32 = sizeToDistribute
						)
						for childIndex := int32(0); childIndex < resizableContainerBuffer.Length; childIndex++ {
							var (
								child     *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childIndex))
								childSize float32
							)
							if xAxis {
								childSize = child.Dimensions.Width
							} else {
								childSize = child.Dimensions.Height
							}
							if __FloatEqual(childSize, smallest) {
								continue
							}
							if childSize < smallest {
								secondSmallest = smallest
								smallest = childSize
							}
							if childSize > smallest {
								if secondSmallest < childSize {
									/* (013) */
								} else {
									secondSmallest = childSize
								}
								widthToAdd = secondSmallest - smallest
							}
						}
						if widthToAdd < (sizeToDistribute / float32(resizableContainerBuffer.Length)) {
							/* (012) */
						} else {
							widthToAdd = sizeToDistribute / float32(resizableContainerBuffer.Length)
						}
						for childIndex := int32(0); childIndex < resizableContainerBuffer.Length; childIndex++ {
							var (
								child     *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childIndex))
								childSize *float32
							)
							if xAxis {
								childSize = &child.Dimensions.Width
							} else {
								childSize = &child.Dimensions.Height
							}
							var maxSize float32
							if xAxis {
								maxSize = child.LayoutConfig.Sizing.Width.Size.MinMax.Max
							} else {
								maxSize = child.LayoutConfig.Sizing.Height.Size.MinMax.Max
							}
							var previousWidth float32 = *childSize
							if __FloatEqual(*childSize, smallest) {
								*childSize += widthToAdd
								if *childSize >= maxSize {
									*childSize = maxSize
									__int32_tArray_RemoveSwapback(&resizableContainerBuffer, func() int32 {
										p_ := &childIndex
										x := *p_
										*p_--
										return x
									}())
								}
								sizeToDistribute -= *childSize - previousWidth
							}
						}
					}
				}
			} else {
				for childOffset := int32(0); childOffset < resizableContainerBuffer.Length; childOffset++ {
					var (
						childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&resizableContainerBuffer, childOffset))
						childSizing  SizingAxis
					)
					if xAxis {
						childSizing = childElement.LayoutConfig.Sizing.Width
					} else {
						childSizing = childElement.LayoutConfig.Sizing.Height
					}
					var minSize float32
					if xAxis {
						minSize = childElement.MinDimensions.Width
					} else {
						minSize = childElement.MinDimensions.Height
					}
					var childSize *float32
					if xAxis {
						childSize = &childElement.Dimensions.Width
					} else {
						childSize = &childElement.Dimensions.Height
					}
					var maxSize float32 = parentSize - parentPadding
					if __ElementHasConfig(parent, __ELEMENT_CONFIG_TYPE_CLIP) {
						var clipElementConfig *ClipElementConfig = __FindElementConfigWithType(parent, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
						if xAxis && clipElementConfig.Horizontal || !xAxis && clipElementConfig.Vertical {
							if maxSize > innerContentSize {
								/* (014) */
							} else {
								maxSize = innerContentSize
							}
						}
					}
					if childSizing.Type == __SIZING_TYPE_GROW {
						if maxSize < childSizing.Size.MinMax.Max {
							*childSize = maxSize
						} else {
							*childSize = childSizing.Size.MinMax.Max
						}
					}
					if minSize > (func() float32 {
						if (*childSize) < maxSize {
							return *childSize
						}
						return maxSize
					}()) {
						*childSize = minSize
					} else if (*childSize) < maxSize {
						/* (015) */
					} else {
						*childSize = maxSize
					}
				}
			}
		}
	}
}

func __IntToString(integer int32) String {
	if integer == 0 {
		return String{Length: 1, Chars: libc.CString("0")}
	}
	var context *Context = GetCurrentContext()
	var chars *byte = ((*byte)(unsafe.Add(unsafe.Pointer(context.dynamicStringData.InternalArray), context.dynamicStringData.Length)))
	var length int32 = 0
	var sign int32 = integer
	if integer < 0 {
		integer = -integer
	}
	for integer > 0 {
		*(*byte)(unsafe.Add(unsafe.Pointer(chars), func() int32 {
			p_ := &length
			x := *p_
			*p_++
			return x
		}())) = byte(int8(integer%10 + '0'))
		integer /= 10
	}
	if sign < 0 {
		*(*byte)(unsafe.Add(unsafe.Pointer(chars), func() int32 {
			p_ := &length
			x := *p_
			*p_++
			return x
		}())) = '-'
	}
	for j, k := int32(0), int32(length-1); j < k; func() int32 {
		j++
		return func() int32 {
			p_ := &k
			x := *p_
			*p_--
			return x
		}()
	}() {
		var temp int8 = int8(*(*byte)(unsafe.Add(unsafe.Pointer(chars), j)))
		*(*byte)(unsafe.Add(unsafe.Pointer(chars), j)) = *(*byte)(unsafe.Add(unsafe.Pointer(chars), k))
		*(*byte)(unsafe.Add(unsafe.Pointer(chars), k)) = byte(temp)
	}
	context.dynamicStringData.Length += length
	return String{Length: length, Chars: chars}
}

func __AddRenderCommand(renderCommand RenderCommand) {
	var context *Context = GetCurrentContext()
	if context.renderCommands.Length < context.renderCommands.Capacity-1 {
		RenderCommandArray_Add(&context.renderCommands, renderCommand)
	} else {
		if !context.booleanWarnings.MaxRenderCommandsExceeded {
			context.booleanWarnings.MaxRenderCommandsExceeded = true
			context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_ELEMENTS_CAPACITY_EXCEEDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay ran out of capacity while attempting to create render commands. This is usually caused by a large amount of wrapping text elements while close to the max element capacity. Try using SetMaxElementCount() with a higher value.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay ran out of capacity while attempting to create render commands. This is usually caused by a large amount of wrapping text elements while close to the max element capacity. Try using SetMaxElementCount() with a higher value.")}, UserData: context.errorHandler.UserData})
		}
	}
}

func __ElementIsOffscreen(boundingBox *BoundingBox) bool {
	var context *Context = GetCurrentContext()
	if context.disableCulling {
		return false
	}
	return boundingBox.X > context.layoutDimensions.Width || boundingBox.Y > context.layoutDimensions.Height || boundingBox.X+boundingBox.Width < 0 || boundingBox.Y+boundingBox.Height < 0
}

func __CalculateFinalLayout() {
	var context *Context = GetCurrentContext()
	__SizeContainersAlongAxis(true)
	for textElementIndex := int32(0); textElementIndex < context.textElementData.Length; textElementIndex++ {
		var textElementData *__TextElementData = __TextElementDataArray_Get(&context.textElementData, textElementIndex)
		textElementData.WrappedLines = __WrappedTextLineArraySlice{Length: 0, InternalArray: (*__WrappedTextLine)(unsafe.Add(unsafe.Pointer(context.wrappedTextLines.InternalArray), unsafe.Sizeof(__WrappedTextLine{})*uintptr(context.wrappedTextLines.Length)))}
		var containerElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, textElementData.ElementIndex)
		var textConfig *TextElementConfig = __FindElementConfigWithType(containerElement, __ELEMENT_CONFIG_TYPE_TEXT).TextElementConfig
		var measureTextCacheItem *__MeasureTextCacheItem = __MeasureTextCached(&textElementData.Text, textConfig)
		var lineWidth float32 = 0
		var lineHeight float32
		if int32(textConfig.LineHeight) > 0 {
			lineHeight = float32(textConfig.LineHeight)
		} else {
			lineHeight = textElementData.PreferredDimensions.Height
		}
		var lineLengthChars int32 = 0
		var lineStartOffset int32 = 0
		if !measureTextCacheItem.ContainsNewlines && textElementData.PreferredDimensions.Width <= containerElement.Dimensions.Width {
			__WrappedTextLineArray_Add(&context.wrappedTextLines, __WrappedTextLine{Dimensions: containerElement.Dimensions, Line: textElementData.Text})
			textElementData.WrappedLines.Length++
			continue
		}
		var spaceWidth float32 = __MeasureText(StringSlice{Length: 1, Chars: __SPACECHAR.Chars, BaseChars: __SPACECHAR.Chars}, textConfig, context.measureTextUserData.(unsafe.Pointer)).Width
		_ = spaceWidth
		var wordIndex int32 = measureTextCacheItem.MeasuredWordsStartIndex
		for wordIndex != -1 {
			if context.wrappedTextLines.Length > context.wrappedTextLines.Capacity-1 {
				break
			}
			var measuredWord *__MeasuredWord = __MeasuredWordArray_Get(&context.measuredWords, wordIndex)
			if lineLengthChars == 0 && lineWidth+measuredWord.Width > containerElement.Dimensions.Width {
				__WrappedTextLineArray_Add(&context.wrappedTextLines, __WrappedTextLine{Dimensions: Dimensions{Width: measuredWord.Width, Height: lineHeight}, Line: String{Length: measuredWord.Length, Chars: (*byte)(unsafe.Add(unsafe.Pointer(textElementData.Text.Chars), measuredWord.StartOffset))}})
				textElementData.WrappedLines.Length++
				wordIndex = measuredWord.Next
				lineStartOffset = measuredWord.StartOffset + measuredWord.Length
			} else if measuredWord.Length == 0 || lineWidth+measuredWord.Width > containerElement.Dimensions.Width {
				var finalCharIsSpace bool = *(*byte)(unsafe.Add(unsafe.Pointer(textElementData.Text.Chars), func() int32 {
					if (lineStartOffset + lineLengthChars - 1) > 0 {
						return lineStartOffset + lineLengthChars - 1
					}
					return 0
				}())) == ' '
				__WrappedTextLineArray_Add(&context.wrappedTextLines, __WrappedTextLine{Dimensions: Dimensions{Width: lineWidth + (func() float32 {
					if finalCharIsSpace {
						return -spaceWidth
					}
					return 0
				}()), Height: lineHeight}, Line: String{Length: lineLengthChars + (func() int32 {
					if finalCharIsSpace {
						return -1
					}
					return 0
				}()), Chars: (*byte)(unsafe.Add(unsafe.Pointer(textElementData.Text.Chars), lineStartOffset))}})
				textElementData.WrappedLines.Length++
				if lineLengthChars == 0 || measuredWord.Length == 0 {
					wordIndex = measuredWord.Next
				}
				lineWidth = 0
				lineLengthChars = 0
				lineStartOffset = measuredWord.StartOffset
			} else {
				lineWidth += measuredWord.Width + float32(textConfig.LetterSpacing)
				lineLengthChars += measuredWord.Length
				wordIndex = measuredWord.Next
			}
		}
		if lineLengthChars > 0 {
			__WrappedTextLineArray_Add(&context.wrappedTextLines, __WrappedTextLine{Dimensions: Dimensions{Width: lineWidth - float32(textConfig.LetterSpacing), Height: lineHeight}, Line: String{Length: lineLengthChars, Chars: (*byte)(unsafe.Add(unsafe.Pointer(textElementData.Text.Chars), lineStartOffset))}})
			textElementData.WrappedLines.Length++
		}
		containerElement.Dimensions.Height = lineHeight * float32(textElementData.WrappedLines.Length)
	}
	for i := int32(0); i < context.AspectRatioElementIndexes.Length; i++ {
		var (
			aspectElement *LayoutElement            = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.AspectRatioElementIndexes, i))
			config        *AspectRatioElementConfig = __FindElementConfigWithType(aspectElement, __ELEMENT_CONFIG_TYPE_ASPECT).AspectRatioElementConfig
		)
		aspectElement.Dimensions.Height = (1 / config.AspectRatio) * aspectElement.Dimensions.Width
		aspectElement.LayoutConfig.Sizing.Height.Size.MinMax.Max = aspectElement.Dimensions.Height
	}
	var dfsBuffer __LayoutElementTreeNodeArray = context.layoutElementTreeNodeArray1
	dfsBuffer.Length = 0
	for i := int32(0); i < context.layoutElementTreeRoots.Length; i++ {
		var root *__LayoutElementTreeRoot = __LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, i)
		*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length)) = false
		__LayoutElementTreeNodeArray_Add(&dfsBuffer, __LayoutElementTreeNode{LayoutElement: LayoutElementArray_Get(&context.layoutElements, root.LayoutElementIndex)})
	}
	for dfsBuffer.Length > 0 {
		var (
			currentElementTreeNode *__LayoutElementTreeNode = __LayoutElementTreeNodeArray_Get(&dfsBuffer, dfsBuffer.Length-1)
			currentElement         *LayoutElement           = currentElementTreeNode.LayoutElement
		)
		if !*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) {
			*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) = true
			if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_TEXT) || int32(currentElement.ChildrenOrTextContent.Children.Length) == 0 {
				dfsBuffer.Length--
				continue
			}
			for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
				*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length)) = false
				__LayoutElementTreeNodeArray_Add(&dfsBuffer, __LayoutElementTreeNode{LayoutElement: LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))})
			}
			continue
		}
		dfsBuffer.Length--
		var layoutConfig *LayoutConfig = currentElement.LayoutConfig
		if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
			for j := int32(0); j < int32(currentElement.ChildrenOrTextContent.Children.Length); j++ {
				var (
					childElement           *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(j))))
					childHeightWithPadding float32        = (func() float32 {
						if (childElement.Dimensions.Height + float32(layoutConfig.Padding.Top) + float32(layoutConfig.Padding.Bottom)) > currentElement.Dimensions.Height {
							return childElement.Dimensions.Height + float32(layoutConfig.Padding.Top) + float32(layoutConfig.Padding.Bottom)
						}
						return currentElement.Dimensions.Height
					}())
				)
				if (func() float32 {
					if childHeightWithPadding > layoutConfig.Sizing.Height.Size.MinMax.Min {
						return childHeightWithPadding
					}
					return layoutConfig.Sizing.Height.Size.MinMax.Min
				}()) < layoutConfig.Sizing.Height.Size.MinMax.Max {
					if childHeightWithPadding > layoutConfig.Sizing.Height.Size.MinMax.Min {
						currentElement.Dimensions.Height = childHeightWithPadding
					} else {
						currentElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Min
					}
				} else {
					currentElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Max
				}
			}
		} else if layoutConfig.LayoutDirection == TOP_TO_BOTTOM {
			var contentHeight float32 = float32(int32(layoutConfig.Padding.Top) + int32(layoutConfig.Padding.Bottom))
			for j := int32(0); j < int32(currentElement.ChildrenOrTextContent.Children.Length); j++ {
				var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(j))))
				contentHeight += childElement.Dimensions.Height
			}
			contentHeight += float32((func() int32 {
				if (int32(currentElement.ChildrenOrTextContent.Children.Length) - 1) > 0 {
					return int32(currentElement.ChildrenOrTextContent.Children.Length) - 1
				}
				return 0
			}()) * int32(layoutConfig.ChildGap))
			if (func() float32 {
				if contentHeight > layoutConfig.Sizing.Height.Size.MinMax.Min {
					return contentHeight
				}
				return layoutConfig.Sizing.Height.Size.MinMax.Min
			}()) < layoutConfig.Sizing.Height.Size.MinMax.Max {
				if contentHeight > layoutConfig.Sizing.Height.Size.MinMax.Min {
					currentElement.Dimensions.Height = contentHeight
				} else {
					currentElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Min
				}
			} else {
				currentElement.Dimensions.Height = layoutConfig.Sizing.Height.Size.MinMax.Max
			}
		}
	}
	__SizeContainersAlongAxis(false)
	for i := int32(0); i < context.AspectRatioElementIndexes.Length; i++ {
		var (
			aspectElement *LayoutElement            = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&context.AspectRatioElementIndexes, i))
			config        *AspectRatioElementConfig = __FindElementConfigWithType(aspectElement, __ELEMENT_CONFIG_TYPE_ASPECT).AspectRatioElementConfig
		)
		aspectElement.Dimensions.Width = config.AspectRatio * aspectElement.Dimensions.Height
	}
	var sortMax int32 = context.layoutElementTreeRoots.Length - 1
	for sortMax > 0 {
		for i := int32(0); i < sortMax; i++ {
			var (
				current __LayoutElementTreeRoot = *__LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, i)
				next    __LayoutElementTreeRoot = *__LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, i+1)
			)
			if int32(next.ZIndex) < int32(current.ZIndex) {
				__LayoutElementTreeRootArray_Set(&context.layoutElementTreeRoots, i, next)
				__LayoutElementTreeRootArray_Set(&context.layoutElementTreeRoots, i+1, current)
			}
		}
		sortMax--
	}
	context.renderCommands.Length = 0
	dfsBuffer.Length = 0
	for rootIndex := int32(0); rootIndex < context.layoutElementTreeRoots.Length; rootIndex++ {
		dfsBuffer.Length = 0
		var root *__LayoutElementTreeRoot = __LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, rootIndex)
		var rootElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, root.LayoutElementIndex)
		var rootPosition Vector2 = Vector2{}
		var parentHashMapItem *LayoutElementHashMapItem = __GetHashMapItem(root.ParentId)
		if __ElementHasConfig(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING) && parentHashMapItem != nil {
			var (
				config               *FloatingElementConfig = __FindElementConfigWithType(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING).FloatingElementConfig
				rootDimensions       Dimensions             = rootElement.Dimensions
				parentBoundingBox    BoundingBox            = parentHashMapItem.BoundingBox
				targetAttachPosition Vector2                = Vector2{}
			)
			switch config.AttachPoints.Parent {
			case ATTACH_POINT_LEFT_TOP:
				fallthrough
			case ATTACH_POINT_LEFT_CENTER:
				fallthrough
			case ATTACH_POINT_LEFT_BOTTOM:
				targetAttachPosition.X = parentBoundingBox.X
			case ATTACH_POINT_CENTER_TOP:
				fallthrough
			case ATTACH_POINT_CENTER_CENTER:
				fallthrough
			case ATTACH_POINT_CENTER_BOTTOM:
				targetAttachPosition.X = parentBoundingBox.X + parentBoundingBox.Width/2
			case ATTACH_POINT_RIGHT_TOP:
				fallthrough
			case ATTACH_POINT_RIGHT_CENTER:
				fallthrough
			case ATTACH_POINT_RIGHT_BOTTOM:
				targetAttachPosition.X = parentBoundingBox.X + parentBoundingBox.Width
			}
			switch config.AttachPoints.Element {
			case ATTACH_POINT_LEFT_TOP:
				fallthrough
			case ATTACH_POINT_LEFT_CENTER:
				fallthrough
			case ATTACH_POINT_LEFT_BOTTOM:
			case ATTACH_POINT_CENTER_TOP:
				fallthrough
			case ATTACH_POINT_CENTER_CENTER:
				fallthrough
			case ATTACH_POINT_CENTER_BOTTOM:
				targetAttachPosition.X -= rootDimensions.Width / 2
			case ATTACH_POINT_RIGHT_TOP:
				fallthrough
			case ATTACH_POINT_RIGHT_CENTER:
				fallthrough
			case ATTACH_POINT_RIGHT_BOTTOM:
				targetAttachPosition.X -= rootDimensions.Width
			}
			switch config.AttachPoints.Parent {
			case ATTACH_POINT_LEFT_TOP:
				fallthrough
			case ATTACH_POINT_RIGHT_TOP:
				fallthrough
			case ATTACH_POINT_CENTER_TOP:
				targetAttachPosition.Y = parentBoundingBox.Y
			case ATTACH_POINT_LEFT_CENTER:
				fallthrough
			case ATTACH_POINT_CENTER_CENTER:
				fallthrough
			case ATTACH_POINT_RIGHT_CENTER:
				targetAttachPosition.Y = parentBoundingBox.Y + parentBoundingBox.Height/2
			case ATTACH_POINT_LEFT_BOTTOM:
				fallthrough
			case ATTACH_POINT_CENTER_BOTTOM:
				fallthrough
			case ATTACH_POINT_RIGHT_BOTTOM:
				targetAttachPosition.Y = parentBoundingBox.Y + parentBoundingBox.Height
			}
			switch config.AttachPoints.Element {
			case ATTACH_POINT_LEFT_TOP:
				fallthrough
			case ATTACH_POINT_RIGHT_TOP:
				fallthrough
			case ATTACH_POINT_CENTER_TOP:
			case ATTACH_POINT_LEFT_CENTER:
				fallthrough
			case ATTACH_POINT_CENTER_CENTER:
				fallthrough
			case ATTACH_POINT_RIGHT_CENTER:
				targetAttachPosition.Y -= rootDimensions.Height / 2
			case ATTACH_POINT_LEFT_BOTTOM:
				fallthrough
			case ATTACH_POINT_CENTER_BOTTOM:
				fallthrough
			case ATTACH_POINT_RIGHT_BOTTOM:
				targetAttachPosition.Y -= rootDimensions.Height
			}
			targetAttachPosition.X += config.Offset.X
			targetAttachPosition.Y += config.Offset.Y
			rootPosition = targetAttachPosition
		}
		if root.ClipElementId != 0 {
			var clipHashMapItem *LayoutElementHashMapItem = __GetHashMapItem(root.ClipElementId)
			if clipHashMapItem != nil {
				if context.externalScrollHandlingEnabled {
					var clipConfig *ClipElementConfig = __FindElementConfigWithType(clipHashMapItem.LayoutElement, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
					if clipConfig.Horizontal {
						rootPosition.X += clipConfig.ChildOffset.X
					}
					if clipConfig.Vertical {
						rootPosition.Y += clipConfig.ChildOffset.Y
					}
				}
				__AddRenderCommand(RenderCommand{BoundingBox: clipHashMapItem.BoundingBox, UserData: 0, Id: __HashNumber(rootElement.Id, uint32(int32(rootElement.ChildrenOrTextContent.Children.Length)+10)).Id, ZIndex: root.ZIndex, CommandType: RENDER_COMMAND_TYPE_SCISSOR_START})
			}
		}
		__LayoutElementTreeNodeArray_Add(&dfsBuffer, __LayoutElementTreeNode{LayoutElement: rootElement, Position: rootPosition, NextChildOffset: Vector2{X: float32(rootElement.LayoutConfig.Padding.Left), Y: float32(rootElement.LayoutConfig.Padding.Top)}})
		*context.treeNodeVisited.InternalArray = false
		for dfsBuffer.Length > 0 {
			var (
				currentElementTreeNode *__LayoutElementTreeNode = __LayoutElementTreeNodeArray_Get(&dfsBuffer, dfsBuffer.Length-1)
				currentElement         *LayoutElement           = currentElementTreeNode.LayoutElement
				layoutConfig           *LayoutConfig            = currentElement.LayoutConfig
				scrollOffset           Vector2                  = Vector2{}
			)
			if !*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) {
				*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) = true
				var currentElementBoundingBox BoundingBox = BoundingBox{X: currentElementTreeNode.Position.X, Y: currentElementTreeNode.Position.Y, Width: currentElement.Dimensions.Width, Height: currentElement.Dimensions.Height}
				if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_FLOATING) {
					var (
						floatingElementConfig *FloatingElementConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_FLOATING).FloatingElementConfig
						expand                Dimensions             = floatingElementConfig.Expand
					)
					currentElementBoundingBox.X -= expand.Width
					currentElementBoundingBox.Width += expand.Width * 2
					currentElementBoundingBox.Y -= expand.Height
					currentElementBoundingBox.Height += expand.Height * 2
				}
				var scrollContainerData *__ScrollContainerDataInternal = (*__ScrollContainerDataInternal)(nil)
				if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_CLIP) {
					var clipConfig *ClipElementConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
					for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
						var mapping *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
						if mapping.LayoutElement == currentElement {
							scrollContainerData = mapping
							mapping.BoundingBox = currentElementBoundingBox
							scrollOffset = clipConfig.ChildOffset
							if context.externalScrollHandlingEnabled {
								scrollOffset = Vector2{}
							}
							break
						}
					}
				}
				var hashMapItem *LayoutElementHashMapItem = __GetHashMapItem(currentElement.Id)
				if hashMapItem != nil {
					hashMapItem.BoundingBox = currentElementBoundingBox
				}
				var sortedConfigIndexes [20]int32
				for elementConfigIndex := int32(0); elementConfigIndex < currentElement.ElementConfigs.Length; elementConfigIndex++ {
					sortedConfigIndexes[elementConfigIndex] = elementConfigIndex
				}
				sortMax = currentElement.ElementConfigs.Length - 1
				for sortMax > 0 {
					for i := int32(0); i < sortMax; i++ {
						var (
							current     int32               = sortedConfigIndexes[i]
							next        int32               = sortedConfigIndexes[i+1]
							currentType __ElementConfigType = __ElementConfigArraySlice_Get(&currentElement.ElementConfigs, current).Type
							nextType    __ElementConfigType = __ElementConfigArraySlice_Get(&currentElement.ElementConfigs, next).Type
						)
						if nextType == __ELEMENT_CONFIG_TYPE_CLIP || currentType == __ELEMENT_CONFIG_TYPE_BORDER {
							sortedConfigIndexes[i] = next
							sortedConfigIndexes[i+1] = current
						}
					}
					sortMax--
				}
				var emitRectangle bool = false
				var sharedConfig *SharedElementConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_SHARED).SharedElementConfig
				if sharedConfig != nil && sharedConfig.BackgroundColor.A > 0 {
					emitRectangle = true
				} else if sharedConfig == nil {
					emitRectangle = false
					sharedConfig = &SharedElementConfig_DEFAULT
				}
				for elementConfigIndex := int32(0); elementConfigIndex < currentElement.ElementConfigs.Length; elementConfigIndex++ {
					var (
						elementConfig *ElementConfig = __ElementConfigArraySlice_Get(&currentElement.ElementConfigs, sortedConfigIndexes[elementConfigIndex])
						renderCommand RenderCommand  = RenderCommand{BoundingBox: currentElementBoundingBox, UserData: sharedConfig.UserData, Id: currentElement.Id}
						offscreen     bool           = __ElementIsOffscreen(&currentElementBoundingBox)
						shouldRender  bool           = !offscreen
					)
					switch elementConfig.Type {
					case __ELEMENT_CONFIG_TYPE_ASPECT:
						fallthrough
					case __ELEMENT_CONFIG_TYPE_FLOATING:
						fallthrough
					case __ELEMENT_CONFIG_TYPE_SHARED:
						fallthrough
					case __ELEMENT_CONFIG_TYPE_BORDER:
						shouldRender = false
					case __ELEMENT_CONFIG_TYPE_CLIP:
						renderCommand.CommandType = RENDER_COMMAND_TYPE_SCISSOR_START
						renderCommand.RenderData = RenderData{Clip: ClipRenderData{Horizontal: elementConfig.Config.ClipElementConfig.Horizontal, Vertical: elementConfig.Config.ClipElementConfig.Vertical}}
					case __ELEMENT_CONFIG_TYPE_IMAGE:
						renderCommand.CommandType = RENDER_COMMAND_TYPE_IMAGE
						renderCommand.RenderData = RenderData{Image: ImageRenderData{BackgroundColor: sharedConfig.BackgroundColor, CornerRadius: sharedConfig.CornerRadius, ImageData: elementConfig.Config.ImageElementConfig.ImageData}}
						emitRectangle = false
					case __ELEMENT_CONFIG_TYPE_TEXT:
						if !shouldRender {
							break
						}
						shouldRender = false
						var configUnion ElementConfigUnion = elementConfig.Config
						var textElementConfig *TextElementConfig = configUnion.TextElementConfig
						var naturalLineHeight float32 = currentElement.ChildrenOrTextContent.TextElementData.PreferredDimensions.Height
						var finalLineHeight float32
						if int32(textElementConfig.LineHeight) > 0 {
							finalLineHeight = float32(textElementConfig.LineHeight)
						} else {
							finalLineHeight = naturalLineHeight
						}
						var lineHeightOffset float32 = (finalLineHeight - naturalLineHeight) / 2
						var yPosition float32 = lineHeightOffset
						for lineIndex := int32(0); lineIndex < currentElement.ChildrenOrTextContent.TextElementData.WrappedLines.Length; lineIndex++ {
							var wrappedLine *__WrappedTextLine = __WrappedTextLineArraySlice_Get(&currentElement.ChildrenOrTextContent.TextElementData.WrappedLines, lineIndex)
							if wrappedLine.Line.Length == 0 {
								yPosition += finalLineHeight
								continue
							}
							var offset float32 = (currentElementBoundingBox.Width - wrappedLine.Dimensions.Width)
							if textElementConfig.TextAlignment == TEXT_ALIGN_LEFT {
								offset = 0
							}
							if textElementConfig.TextAlignment == TEXT_ALIGN_CENTER {
								offset /= 2
							}
							__AddRenderCommand(RenderCommand{BoundingBox: BoundingBox{X: currentElementBoundingBox.X + offset, Y: currentElementBoundingBox.Y + yPosition, Width: wrappedLine.Dimensions.Width, Height: wrappedLine.Dimensions.Height}, RenderData: RenderData{Text: TextRenderData{StringContents: StringSlice{Length: wrappedLine.Line.Length, Chars: wrappedLine.Line.Chars, BaseChars: currentElement.ChildrenOrTextContent.TextElementData.Text.Chars}, TextColor: textElementConfig.TextColor, FontId: textElementConfig.FontId, FontSize: textElementConfig.FontSize, LetterSpacing: textElementConfig.LetterSpacing, LineHeight: textElementConfig.LineHeight}}, UserData: textElementConfig.UserData, Id: __HashNumber(uint32(lineIndex), currentElement.Id).Id, ZIndex: root.ZIndex, CommandType: RENDER_COMMAND_TYPE_TEXT})
							yPosition += finalLineHeight
							if !context.disableCulling && currentElementBoundingBox.Y+yPosition > context.layoutDimensions.Height {
								break
							}
						}
					case __ELEMENT_CONFIG_TYPE_CUSTOM:
						renderCommand.CommandType = RENDER_COMMAND_TYPE_CUSTOM
						renderCommand.RenderData = RenderData{Custom: CustomRenderData{BackgroundColor: sharedConfig.BackgroundColor, CornerRadius: sharedConfig.CornerRadius, CustomData: elementConfig.Config.CustomElementConfig.CustomData}}
						emitRectangle = false
					default:
					}
					if shouldRender {
						__AddRenderCommand(renderCommand)
					}
					if offscreen {
					}
				}
				if emitRectangle {
					__AddRenderCommand(RenderCommand{BoundingBox: currentElementBoundingBox, RenderData: RenderData{Rectangle: RectangleRenderData{BackgroundColor: sharedConfig.BackgroundColor, CornerRadius: sharedConfig.CornerRadius}}, UserData: sharedConfig.UserData, Id: currentElement.Id, ZIndex: root.ZIndex, CommandType: RENDER_COMMAND_TYPE_RECTANGLE})
				}
				if !__ElementHasConfig(currentElementTreeNode.LayoutElement, __ELEMENT_CONFIG_TYPE_TEXT) {
					var contentSize Dimensions = Dimensions{}
					if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
						for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
							var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
							contentSize.Width += childElement.Dimensions.Width
							if contentSize.Height > childElement.Dimensions.Height {
								/* (016) */
							} else {
								contentSize.Height = childElement.Dimensions.Height
							}
						}
						contentSize.Width += float32((func() int32 {
							if (int32(currentElement.ChildrenOrTextContent.Children.Length) - 1) > 0 {
								return int32(currentElement.ChildrenOrTextContent.Children.Length) - 1
							}
							return 0
						}()) * int32(layoutConfig.ChildGap))
						var extraSpace float32 = currentElement.Dimensions.Width - float32(int32(layoutConfig.Padding.Left)+int32(layoutConfig.Padding.Right)) - contentSize.Width
						switch layoutConfig.ChildAlignment.X {
						case ALIGN_X_LEFT:
							extraSpace = 0
						case ALIGN_X_CENTER:
							extraSpace /= 2
						default:
						}
						currentElementTreeNode.NextChildOffset.X += extraSpace
						if 0 > extraSpace {
							extraSpace = 0
						} else {
							/* (023) */
						}
					} else {
						for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
							var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
							if contentSize.Width > childElement.Dimensions.Width {
								/* (017) */
							} else {
								contentSize.Width = childElement.Dimensions.Width
							}
							contentSize.Height += childElement.Dimensions.Height
						}
						contentSize.Height += float32((func() int32 {
							if (int32(currentElement.ChildrenOrTextContent.Children.Length) - 1) > 0 {
								return int32(currentElement.ChildrenOrTextContent.Children.Length) - 1
							}
							return 0
						}()) * int32(layoutConfig.ChildGap))
						var extraSpace float32 = currentElement.Dimensions.Height - float32(int32(layoutConfig.Padding.Top)+int32(layoutConfig.Padding.Bottom)) - contentSize.Height
						switch layoutConfig.ChildAlignment.Y {
						case ALIGN_Y_TOP:
							extraSpace = 0
						case ALIGN_Y_CENTER:
							extraSpace /= 2
						default:
						}
						if 0 > extraSpace {
							extraSpace = 0
						} else {
							/* (023) */
						}
						currentElementTreeNode.NextChildOffset.Y += extraSpace
					}
					if scrollContainerData != nil {
						scrollContainerData.ContentSize = Dimensions{Width: contentSize.Width + float32(int32(layoutConfig.Padding.Left)+int32(layoutConfig.Padding.Right)), Height: contentSize.Height + float32(int32(layoutConfig.Padding.Top)+int32(layoutConfig.Padding.Bottom))}
					}
				}
			} else {
				var (
					closeClipElement bool               = false
					clipConfig       *ClipElementConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
				)
				if clipConfig != nil {
					closeClipElement = true
					for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
						var mapping *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
						if mapping.LayoutElement == currentElement {
							scrollOffset = clipConfig.ChildOffset
							if context.externalScrollHandlingEnabled {
								scrollOffset = Vector2{}
							}
							break
						}
					}
				}
				if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_BORDER) {
					var (
						currentElementData        *LayoutElementHashMapItem = __GetHashMapItem(currentElement.Id)
						currentElementBoundingBox BoundingBox               = currentElementData.BoundingBox
					)
					if !__ElementIsOffscreen(&currentElementBoundingBox) {
						var sharedConfig *SharedElementConfig
						if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_SHARED) {
							sharedConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_SHARED).SharedElementConfig
						} else {
							sharedConfig = &SharedElementConfig_DEFAULT
						}
						var borderConfig *BorderElementConfig = __FindElementConfigWithType(currentElement, __ELEMENT_CONFIG_TYPE_BORDER).BorderElementConfig
						var renderCommand RenderCommand = RenderCommand{BoundingBox: currentElementBoundingBox, RenderData: RenderData{Border: BorderRenderData{Color: borderConfig.Color, CornerRadius: sharedConfig.CornerRadius, Width: borderConfig.Width}}, UserData: sharedConfig.UserData, Id: __HashNumber(currentElement.Id, uint32(currentElement.ChildrenOrTextContent.Children.Length)).Id, CommandType: RENDER_COMMAND_TYPE_BORDER}
						__AddRenderCommand(renderCommand)
						if int32(borderConfig.Width.BetweenChildren) > 0 && borderConfig.Color.A > 0 {
							var (
								halfGap      float32 = float32(int32(layoutConfig.ChildGap) / 2)
								borderOffset Vector2 = Vector2{X: float32(layoutConfig.Padding.Left) - halfGap, Y: float32(layoutConfig.Padding.Top) - halfGap}
							)
							if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
								for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
									var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
									if i > 0 {
										__AddRenderCommand(RenderCommand{BoundingBox: BoundingBox{X: currentElementBoundingBox.X + borderOffset.X + scrollOffset.X, Y: currentElementBoundingBox.Y + scrollOffset.Y, Width: float32(borderConfig.Width.BetweenChildren), Height: currentElement.Dimensions.Height}, RenderData: RenderData{Rectangle: RectangleRenderData{BackgroundColor: borderConfig.Color}}, UserData: sharedConfig.UserData, Id: __HashNumber(currentElement.Id, uint32(int32(currentElement.ChildrenOrTextContent.Children.Length)+1+i)).Id, CommandType: RENDER_COMMAND_TYPE_RECTANGLE})
									}
									borderOffset.X += childElement.Dimensions.Width + float32(layoutConfig.ChildGap)
								}
							} else {
								for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
									var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
									if i > 0 {
										__AddRenderCommand(RenderCommand{BoundingBox: BoundingBox{X: currentElementBoundingBox.X + scrollOffset.X, Y: currentElementBoundingBox.Y + borderOffset.Y + scrollOffset.Y, Width: currentElement.Dimensions.Width, Height: float32(borderConfig.Width.BetweenChildren)}, RenderData: RenderData{Rectangle: RectangleRenderData{BackgroundColor: borderConfig.Color}}, UserData: sharedConfig.UserData, Id: __HashNumber(currentElement.Id, uint32(int32(currentElement.ChildrenOrTextContent.Children.Length)+1+i)).Id, CommandType: RENDER_COMMAND_TYPE_RECTANGLE})
									}
									borderOffset.Y += childElement.Dimensions.Height + float32(layoutConfig.ChildGap)
								}
							}
						}
					}
				}
				if closeClipElement {
					__AddRenderCommand(RenderCommand{Id: __HashNumber(currentElement.Id, uint32(int32(rootElement.ChildrenOrTextContent.Children.Length)+11)).Id, CommandType: RENDER_COMMAND_TYPE_SCISSOR_END})
				}
				dfsBuffer.Length--
				continue
			}
			if !__ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_TEXT) {
				dfsBuffer.Length += int32(currentElement.ChildrenOrTextContent.Children.Length)
				for i := int32(0); i < int32(currentElement.ChildrenOrTextContent.Children.Length); i++ {
					var childElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
					if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
						currentElementTreeNode.NextChildOffset.Y = float32(currentElement.LayoutConfig.Padding.Top)
						var whiteSpaceAroundChild float32 = currentElement.Dimensions.Height - float32(int32(layoutConfig.Padding.Top)+int32(layoutConfig.Padding.Bottom)) - childElement.Dimensions.Height
						switch layoutConfig.ChildAlignment.Y {
						case ALIGN_Y_TOP:
						case ALIGN_Y_CENTER:
							currentElementTreeNode.NextChildOffset.Y += whiteSpaceAroundChild / 2
						case ALIGN_Y_BOTTOM:
							currentElementTreeNode.NextChildOffset.Y += whiteSpaceAroundChild
						}
					} else {
						currentElementTreeNode.NextChildOffset.X = float32(currentElement.LayoutConfig.Padding.Left)
						var whiteSpaceAroundChild float32 = currentElement.Dimensions.Width - float32(int32(layoutConfig.Padding.Left)+int32(layoutConfig.Padding.Right)) - childElement.Dimensions.Width
						switch layoutConfig.ChildAlignment.X {
						case ALIGN_X_LEFT:
						case ALIGN_X_CENTER:
							currentElementTreeNode.NextChildOffset.X += whiteSpaceAroundChild / 2
						case ALIGN_X_RIGHT:
							currentElementTreeNode.NextChildOffset.X += whiteSpaceAroundChild
						}
					}
					var childPosition Vector2 = Vector2{X: currentElementTreeNode.Position.X + currentElementTreeNode.NextChildOffset.X + scrollOffset.X, Y: currentElementTreeNode.Position.Y + currentElementTreeNode.NextChildOffset.Y + scrollOffset.Y}
					var newNodeIndex uint32 = uint32(dfsBuffer.Length - 1 - i)
					*(*__LayoutElementTreeNode)(unsafe.Add(unsafe.Pointer(dfsBuffer.InternalArray), unsafe.Sizeof(__LayoutElementTreeNode{})*uintptr(newNodeIndex))) = __LayoutElementTreeNode{LayoutElement: childElement, Position: Vector2{X: childPosition.X, Y: childPosition.Y}, NextChildOffset: Vector2{X: float32(childElement.LayoutConfig.Padding.Left), Y: float32(childElement.LayoutConfig.Padding.Top)}}
					*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), newNodeIndex)) = false
					if layoutConfig.LayoutDirection == LEFT_TO_RIGHT {
						currentElementTreeNode.NextChildOffset.X += childElement.Dimensions.Width + float32(layoutConfig.ChildGap)
					} else {
						currentElementTreeNode.NextChildOffset.Y += childElement.Dimensions.Height + float32(layoutConfig.ChildGap)
					}
				}
			}
		}
		if root.ClipElementId != 0 {
			__AddRenderCommand(RenderCommand{Id: __HashNumber(rootElement.Id, uint32(int32(rootElement.ChildrenOrTextContent.Children.Length)+11)).Id, CommandType: RENDER_COMMAND_TYPE_SCISSOR_END})
		}
	}
}

func GetPointerOverIds() ElementIdArray {
	return GetCurrentContext().pointerOverIds
}

var (
	__debugViewWidth          uint32 = 400
	__debugViewHighlightColor Color  = Color{R: 168, G: 66, B: 28, A: 100}
)

func __WarningArray_Allocate_Arena(capacity int32, arena *Arena) __WarningArray {
	var (
		totalSizeBytes  uint64         = uint64(uintptr(capacity) * unsafe.Sizeof(String{}))
		array           __WarningArray = __WarningArray{Capacity: capacity, Length: 0}
		nextAllocOffset uint64         = arena.NextAllocation + (64 - arena.NextAllocation%64)
	)
	if nextAllocOffset+totalSizeBytes <= arena.Capacity {
		array.InternalArray = (*__Warning)(unsafe.Pointer(uintptr(uint64(uintptr(unsafe.Pointer(arena.Memory))) + nextAllocOffset)))
		arena.NextAllocation = nextAllocOffset + totalSizeBytes
	} else {
		__currentContext.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_ARENA_CAPACITY_EXCEEDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Initialize()") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Initialize()")}, UserData: __currentContext.errorHandler.UserData})
	}
	return array
}

func __WarningArray_Add(array *__WarningArray, item __Warning) *__Warning {
	if array.Length < array.Capacity {
		*(*__Warning)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__Warning{})*uintptr(func() int32 {
			p_ := &array.Length
			x := *p_
			*p_++
			return x
		}()))) = item
		return (*__Warning)(unsafe.Add(unsafe.Pointer(array.InternalArray), unsafe.Sizeof(__Warning{})*uintptr(array.Length-1)))
	}
	return &__WARNING_DEFAULT
}

func __Array_Allocate_Arena(capacity int32, itemSize uint32, arena *Arena) unsafe.Pointer {
	var (
		totalSizeBytes  uint64 = uint64(uint32(capacity) * itemSize)
		nextAllocOffset uint64 = arena.NextAllocation + ((64 - arena.NextAllocation%64) & 63)
	)
	if nextAllocOffset+totalSizeBytes <= arena.Capacity {
		arena.NextAllocation = nextAllocOffset + totalSizeBytes
		return unsafe.Pointer(uintptr(uint64(uintptr(unsafe.Pointer(arena.Memory))) + nextAllocOffset))
	} else {
		__currentContext.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_ARENA_CAPACITY_EXCEEDED, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Initialize()") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay attempted to allocate memory in its arena, but ran out of capacity. Try increasing the capacity of the arena passed to Initialize()")}, UserData: __currentContext.errorHandler.UserData})
	}
	return nil
}

func __Array_RangeCheck(index int32, length int32) bool {
	if index < length && index >= 0 {
		return true
	}
	var context *Context = GetCurrentContext()
	context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_INTERNAL_ERROR, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.")}, UserData: context.errorHandler.UserData})
	return false
}

func __Array_AddCapacityCheck(length int32, capacity int32) bool {
	if length < capacity {
		return true
	}
	var context *Context = GetCurrentContext()
	context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_INTERNAL_ERROR, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay attempted to make an out of bounds array access. This is an internal error and is likely a bug.")}, UserData: context.errorHandler.UserData})
	return false
}

func MinMemorySize() uint32 {
	var (
		fakeContext    Context  = Context{maxElementCount: __defaultMaxElementCount, maxMeasureTextCacheWordCount: __defaultMaxMeasureTextWordCacheCount, internalArena: Arena{Capacity: math.MaxUint64, Memory: nil}}
		currentContext *Context = GetCurrentContext()
	)
	if currentContext != nil {
		fakeContext.maxElementCount = currentContext.maxElementCount
		fakeContext.maxMeasureTextCacheWordCount = currentContext.maxMeasureTextCacheWordCount
	}
	__Context_Allocate_Arena(&fakeContext.internalArena)
	__InitializePersistentMemory(&fakeContext)
	__InitializeEphemeralMemory(&fakeContext)
	return uint32(fakeContext.internalArena.NextAllocation) + 128
}

func createArenaWithCapacityAndMemory(capacity uint64, memory unsafe.Pointer) Arena {
	var arena Arena = Arena{Capacity: capacity, Memory: (*byte)(memory)}
	return arena
}

func SetMeasureTextFunction(measureTextFunction func(text StringSlice, config *TextElementConfig, userData unsafe.Pointer) Dimensions, userData any) {
	var context *Context = GetCurrentContext()
	__MeasureText = measureTextFunction
	context.measureTextUserData = userData
}

func SetQueryScrollOffsetFunction(queryScrollOffsetFunction func(elementId uint32, userData unsafe.Pointer) Vector2, userData any) {
	var context *Context = GetCurrentContext()
	__QueryScrollOffset = queryScrollOffsetFunction
	context.queryScrollOffsetUserData = userData
}

func SetLayoutDimensions(dimensions Dimensions) {
	GetCurrentContext().layoutDimensions = dimensions
}

func SetPointerState(position Vector2, isPointerDown bool) {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return
	}
	context.pointerInfo.Position = position
	context.pointerOverIds.Length = 0
	var dfsBuffer __int32_tArray = context.layoutElementChildrenBuffer
	for rootIndex := int32(context.layoutElementTreeRoots.Length - 1); rootIndex >= 0; rootIndex-- {
		dfsBuffer.Length = 0
		var root *__LayoutElementTreeRoot = __LayoutElementTreeRootArray_Get(&context.layoutElementTreeRoots, rootIndex)
		__int32_tArray_Add(&dfsBuffer, root.LayoutElementIndex)
		*context.treeNodeVisited.InternalArray = false
		var found bool = false
		for dfsBuffer.Length > 0 {
			if *(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) {
				dfsBuffer.Length--
				continue
			}
			*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) = true
			var currentElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, __int32_tArray_GetValue(&dfsBuffer, dfsBuffer.Length-1))
			var mapItem *LayoutElementHashMapItem = __GetHashMapItem(currentElement.Id)
			var clipElementId int32 = __int32_tArray_GetValue(&context.layoutElementClipElementIds, int32(int64((uintptr(unsafe.Pointer(currentElement))-uintptr(unsafe.Pointer(context.layoutElements.InternalArray)))/unsafe.Sizeof(LayoutElement{}))))
			var clipItem *LayoutElementHashMapItem = __GetHashMapItem(uint32(clipElementId))
			if mapItem != nil {
				var elementBox BoundingBox = mapItem.BoundingBox
				elementBox.X -= root.PointerOffset.X
				elementBox.Y -= root.PointerOffset.Y
				if __PointIsInsideRect(position, elementBox) && (clipElementId == 0 || __PointIsInsideRect(position, clipItem.BoundingBox) || context.externalScrollHandlingEnabled) {
					if mapItem.OnHoverFunction != nil {
						mapItem.OnHoverFunction(mapItem.ElementId, context.pointerInfo, mapItem.HoverFunctionUserData.(int64))
					}
					ElementIdArray_Add(&context.pointerOverIds, mapItem.ElementId)
					found = true
				}
				if __ElementHasConfig(currentElement, __ELEMENT_CONFIG_TYPE_TEXT) {
					dfsBuffer.Length--
					continue
				}
				for i := int32(int32(currentElement.ChildrenOrTextContent.Children.Length) - 1); i >= 0; i-- {
					__int32_tArray_Add(&dfsBuffer, *(*int32)(unsafe.Add(unsafe.Pointer(currentElement.ChildrenOrTextContent.Children.Elements), unsafe.Sizeof(int32(0))*uintptr(i))))
					*(*bool)(unsafe.Add(unsafe.Pointer(context.treeNodeVisited.InternalArray), dfsBuffer.Length-1)) = false
				}
			} else {
				dfsBuffer.Length--
			}
		}
		var rootElement *LayoutElement = LayoutElementArray_Get(&context.layoutElements, root.LayoutElementIndex)
		if found && __ElementHasConfig(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING) && __FindElementConfigWithType(rootElement, __ELEMENT_CONFIG_TYPE_FLOATING).FloatingElementConfig.PointerCaptureMode == POINTER_CAPTURE_MODE_CAPTURE {
			break
		}
	}
	if isPointerDown {
		if context.pointerInfo.State == POINTER_DATA_PRESSED_THIS_FRAME {
			context.pointerInfo.State = POINTER_DATA_PRESSED
		} else if context.pointerInfo.State != POINTER_DATA_PRESSED {
			context.pointerInfo.State = POINTER_DATA_PRESSED_THIS_FRAME
		}
	} else {
		if context.pointerInfo.State == POINTER_DATA_RELEASED_THIS_FRAME {
			context.pointerInfo.State = POINTER_DATA_RELEASED
		} else if context.pointerInfo.State != POINTER_DATA_RELEASED {
			context.pointerInfo.State = POINTER_DATA_RELEASED_THIS_FRAME
		}
	}
}

func Initialize(arena Arena, layoutDimensions Dimensions, errorHandler ErrorHandler) *Context {
	var baseOffset uint64 = 64 - uint64(uintptr(unsafe.Pointer(arena.Memory)))%64
	if baseOffset == 64 {
		baseOffset = 0
	} else {
		/* (024) */
	}
	arena.Memory = (*byte)(unsafe.Add(unsafe.Pointer(arena.Memory), baseOffset))
	var context *Context = __Context_Allocate_Arena(&arena)
	if context == nil {
		return nil
	}
	var oldContext *Context = GetCurrentContext()
	*context = Context{maxElementCount: func() int32 {
		if oldContext != nil {
			return oldContext.maxElementCount
		}
		return __defaultMaxElementCount
	}(), maxMeasureTextCacheWordCount: func() int32 {
		if oldContext != nil {
			return oldContext.maxMeasureTextCacheWordCount
		}
		return __defaultMaxMeasureTextWordCacheCount
	}(), errorHandler: func() ErrorHandler {
		if errorHandler.ErrorHandlerFunction != nil {
			return errorHandler
		}
		return ErrorHandler{ErrorHandlerFunction: __ErrorHandlerFunctionDefault, UserData: 0}
	}(), layoutDimensions: layoutDimensions, internalArena: arena}
	SetCurrentContext(context)
	__InitializePersistentMemory(context)
	__InitializeEphemeralMemory(context)
	for i := int32(0); i < context.layoutElementsHashMap.Capacity; i++ {
		*(*int32)(unsafe.Add(unsafe.Pointer(context.layoutElementsHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(i))) = -1
	}
	for i := int32(0); i < context.measureTextHashMap.Capacity; i++ {
		*(*int32)(unsafe.Add(unsafe.Pointer(context.measureTextHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(i))) = 0
	}
	context.measureTextHashMapInternal.Length = 1
	context.layoutDimensions = layoutDimensions
	return context
}

func GetCurrentContext() *Context {
	return __currentContext
}

func SetCurrentContext(context *Context) {
	__currentContext = context
}

func GetScrollOffset() Vector2 {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return Vector2{}
	}
	var openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	if openLayoutElement.Id == 0 {
		__GenerateIdForAnonymousElement(openLayoutElement)
	}
	for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
		var mapping *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
		if mapping.LayoutElement == openLayoutElement {
			return mapping.ScrollPosition
		}
	}
	return Vector2{}
}

func UpdateScrollContainers(enableDragScrolling bool, scrollDelta Vector2, deltaTime float32) {
	var (
		context                     *Context                       = GetCurrentContext()
		isPointerActive             bool                           = enableDragScrolling && (context.pointerInfo.State == POINTER_DATA_PRESSED || context.pointerInfo.State == POINTER_DATA_PRESSED_THIS_FRAME)
		highestPriorityElementIndex int32                          = -1
		highestPriorityScrollData   *__ScrollContainerDataInternal = (*__ScrollContainerDataInternal)(nil)
	)
	for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
		var scrollData *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
		if !scrollData.OpenThisFrame {
			__ScrollContainerDataInternalArray_RemoveSwapback(&context.scrollContainerDatas, i)
			continue
		}
		scrollData.OpenThisFrame = false
		var hashMapItem *LayoutElementHashMapItem = __GetHashMapItem(scrollData.ElementId)
		if hashMapItem == nil {
			__ScrollContainerDataInternalArray_RemoveSwapback(&context.scrollContainerDatas, i)
			continue
		}
		if !isPointerActive && scrollData.PointerScrollActive {
			var xDiff float32 = scrollData.ScrollPosition.X - scrollData.ScrollOrigin.X
			if xDiff < -10 || xDiff > 10 {
				scrollData.ScrollMomentum.X = (scrollData.ScrollPosition.X - scrollData.ScrollOrigin.X) / (scrollData.MomentumTime * 25)
			}
			var yDiff float32 = scrollData.ScrollPosition.Y - scrollData.ScrollOrigin.Y
			if yDiff < -10 || yDiff > 10 {
				scrollData.ScrollMomentum.Y = (scrollData.ScrollPosition.Y - scrollData.ScrollOrigin.Y) / (scrollData.MomentumTime * 25)
			}
			scrollData.PointerScrollActive = false
			scrollData.PointerOrigin = Vector2{}
			scrollData.ScrollOrigin = Vector2{}
			scrollData.MomentumTime = 0
		}
		scrollData.ScrollPosition.X += scrollData.ScrollMomentum.X
		scrollData.ScrollMomentum.X *= 0.95
		var scrollOccurred bool = scrollDelta.X != 0 || scrollDelta.Y != 0
		if scrollData.ScrollMomentum.X > -0.1 && scrollData.ScrollMomentum.X < 0.1 || scrollOccurred {
			scrollData.ScrollMomentum.X = 0
		}
		if (func() float32 {
			if scrollData.ScrollPosition.X > (-func() float32 {
				if (scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width) > 0 {
					return scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width
				}
				return 0
			}()) {
				return scrollData.ScrollPosition.X
			}
			return -func() float32 {
				if (scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width) > 0 {
					return scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width
				}
				return 0
			}()
		}()) < 0 {
			if scrollData.ScrollPosition.X > (-func() float32 {
				if (scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width) > 0 {
					return scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width
				}
				return 0
			}()) {
				/* (018) */
			} else if (scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width) > 0 {
				scrollData.ScrollPosition.X = -(scrollData.ContentSize.Width - scrollData.LayoutElement.Dimensions.Width)
			} else {
				scrollData.ScrollPosition.X = 0
			}
		} else {
			scrollData.ScrollPosition.X = 0
		}
		scrollData.ScrollPosition.Y += scrollData.ScrollMomentum.Y
		scrollData.ScrollMomentum.Y *= 0.95
		if scrollData.ScrollMomentum.Y > -0.1 && scrollData.ScrollMomentum.Y < 0.1 || scrollOccurred {
			scrollData.ScrollMomentum.Y = 0
		}
		if (func() float32 {
			if scrollData.ScrollPosition.Y > (-func() float32 {
				if (scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height) > 0 {
					return scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height
				}
				return 0
			}()) {
				return scrollData.ScrollPosition.Y
			}
			return -func() float32 {
				if (scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height) > 0 {
					return scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height
				}
				return 0
			}()
		}()) < 0 {
			if scrollData.ScrollPosition.Y > (-func() float32 {
				if (scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height) > 0 {
					return scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height
				}
				return 0
			}()) {
				/* (019) */
			} else if (scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height) > 0 {
				scrollData.ScrollPosition.Y = -(scrollData.ContentSize.Height - scrollData.LayoutElement.Dimensions.Height)
			} else {
				scrollData.ScrollPosition.Y = 0
			}
		} else {
			scrollData.ScrollPosition.Y = 0
		}
		for j := int32(0); j < context.pointerOverIds.Length; j++ {
			if scrollData.LayoutElement.Id == ElementIdArray_Get(&context.pointerOverIds, j).Id {
				highestPriorityElementIndex = j
				highestPriorityScrollData = scrollData
			}
		}
	}
	if highestPriorityElementIndex > -1 && highestPriorityScrollData != nil {
		var (
			scrollElement         *LayoutElement     = highestPriorityScrollData.LayoutElement
			clipConfig            *ClipElementConfig = __FindElementConfigWithType(scrollElement, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
			canScrollVertically   bool               = clipConfig.Vertical && highestPriorityScrollData.ContentSize.Height > scrollElement.Dimensions.Height
			canScrollHorizontally bool               = clipConfig.Horizontal && highestPriorityScrollData.ContentSize.Width > scrollElement.Dimensions.Width
		)
		if canScrollVertically {
			highestPriorityScrollData.ScrollPosition.Y = highestPriorityScrollData.ScrollPosition.Y + scrollDelta.Y*10
		}
		if canScrollHorizontally {
			highestPriorityScrollData.ScrollPosition.X = highestPriorityScrollData.ScrollPosition.X + scrollDelta.X*10
		}
		if isPointerActive {
			highestPriorityScrollData.ScrollMomentum = Vector2{}
			if !highestPriorityScrollData.PointerScrollActive {
				highestPriorityScrollData.PointerOrigin = context.pointerInfo.Position
				highestPriorityScrollData.ScrollOrigin = highestPriorityScrollData.ScrollPosition
				highestPriorityScrollData.PointerScrollActive = true
			} else {
				var (
					scrollDeltaX float32 = 0
					scrollDeltaY float32 = 0
				)
				if canScrollHorizontally {
					var oldXScrollPosition float32 = highestPriorityScrollData.ScrollPosition.X
					highestPriorityScrollData.ScrollPosition.X = highestPriorityScrollData.ScrollOrigin.X + (context.pointerInfo.Position.X - highestPriorityScrollData.PointerOrigin.X)
					if (func() float32 {
						if highestPriorityScrollData.ScrollPosition.X < 0 {
							return highestPriorityScrollData.ScrollPosition.X
						}
						return 0
					}()) > (-(highestPriorityScrollData.ContentSize.Width - highestPriorityScrollData.BoundingBox.Width)) {
						if highestPriorityScrollData.ScrollPosition.X < 0 {
							/* (020) */
						} else {
							highestPriorityScrollData.ScrollPosition.X = 0
						}
					} else {
						highestPriorityScrollData.ScrollPosition.X = -(highestPriorityScrollData.ContentSize.Width - highestPriorityScrollData.BoundingBox.Width)
					}
					scrollDeltaX = highestPriorityScrollData.ScrollPosition.X - oldXScrollPosition
				}
				if canScrollVertically {
					var oldYScrollPosition float32 = highestPriorityScrollData.ScrollPosition.Y
					highestPriorityScrollData.ScrollPosition.Y = highestPriorityScrollData.ScrollOrigin.Y + (context.pointerInfo.Position.Y - highestPriorityScrollData.PointerOrigin.Y)
					if (func() float32 {
						if highestPriorityScrollData.ScrollPosition.Y < 0 {
							return highestPriorityScrollData.ScrollPosition.Y
						}
						return 0
					}()) > (-(highestPriorityScrollData.ContentSize.Height - highestPriorityScrollData.BoundingBox.Height)) {
						if highestPriorityScrollData.ScrollPosition.Y < 0 {
							/* (021) */
						} else {
							highestPriorityScrollData.ScrollPosition.Y = 0
						}
					} else {
						highestPriorityScrollData.ScrollPosition.Y = -(highestPriorityScrollData.ContentSize.Height - highestPriorityScrollData.BoundingBox.Height)
					}
					scrollDeltaY = highestPriorityScrollData.ScrollPosition.Y - oldYScrollPosition
				}
				if scrollDeltaX > -0.1 && scrollDeltaX < 0.1 && scrollDeltaY > -0.1 && scrollDeltaY < 0.1 && highestPriorityScrollData.MomentumTime > 0.15 {
					highestPriorityScrollData.MomentumTime = 0
					highestPriorityScrollData.PointerOrigin = context.pointerInfo.Position
					highestPriorityScrollData.ScrollOrigin = highestPriorityScrollData.ScrollPosition
				} else {
					highestPriorityScrollData.MomentumTime += deltaTime
				}
			}
		}
		if canScrollVertically {
			if (func() float32 {
				if highestPriorityScrollData.ScrollPosition.Y < 0 {
					return highestPriorityScrollData.ScrollPosition.Y
				}
				return 0
			}()) > (-(highestPriorityScrollData.ContentSize.Height - scrollElement.Dimensions.Height)) {
				if highestPriorityScrollData.ScrollPosition.Y < 0 {
					/* (021) */
				} else {
					highestPriorityScrollData.ScrollPosition.Y = 0
				}
			} else {
				highestPriorityScrollData.ScrollPosition.Y = -(highestPriorityScrollData.ContentSize.Height - scrollElement.Dimensions.Height)
			}
		}
		if canScrollHorizontally {
			if (func() float32 {
				if highestPriorityScrollData.ScrollPosition.X < 0 {
					return highestPriorityScrollData.ScrollPosition.X
				}
				return 0
			}()) > (-(highestPriorityScrollData.ContentSize.Width - scrollElement.Dimensions.Width)) {
				if highestPriorityScrollData.ScrollPosition.X < 0 {
					/* (020) */
				} else {
					highestPriorityScrollData.ScrollPosition.X = 0
				}
			} else {
				highestPriorityScrollData.ScrollPosition.X = -(highestPriorityScrollData.ContentSize.Width - scrollElement.Dimensions.Width)
			}
		}
	}
}

func BeginLayout() {
	var context *Context = GetCurrentContext()
	__InitializeEphemeralMemory(context)
	context.generation++
	context.dynamicElementIndex = 0
	var rootDimensions Dimensions = Dimensions{Width: context.layoutDimensions.Width, Height: context.layoutDimensions.Height}
	if context.debugModeEnabled {
		rootDimensions.Width -= float32(__debugViewWidth)
	}
	context.booleanWarnings = BooleanWarnings{MaxElementsExceeded: false}
	__OpenElementWithId(__HashString(String{IsStaticallyAllocated: true, Length: int32(((len("__RootContainer") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("__RootContainer")}, 0))
	__ConfigureOpenElement(ElementDeclaration{Layout: LayoutConfig{Sizing: Sizing{Width: SizingAxis{Size: struct {
		// union
		MinMax  SizingMinMax
		Percent float32
	}{MinMax: SizingMinMax{Min: rootDimensions.Width, Max: rootDimensions.Width}}, Type: __SIZING_TYPE_FIXED}, Height: SizingAxis{Size: struct {
		// union
		MinMax  SizingMinMax
		Percent float32
	}{MinMax: SizingMinMax{Min: rootDimensions.Height, Max: rootDimensions.Height}}, Type: __SIZING_TYPE_FIXED}}}})
	__int32_tArray_Add(&context.openLayoutElementStack, 0)
	__LayoutElementTreeRootArray_Add(&context.layoutElementTreeRoots, __LayoutElementTreeRoot{})
}

func EndLayout() RenderCommandArray {
	var context *Context = GetCurrentContext()
	__CloseElement()
	var elementsExceededBeforeDebugView bool = context.booleanWarnings.MaxElementsExceeded
	if context.booleanWarnings.MaxElementsExceeded {
		var message String
		if !elementsExceededBeforeDebugView {
			message = String{IsStaticallyAllocated: true, Length: int32(((len("Clay Error: Layout elements exceeded __maxElementCount after adding the debug-view to the layout.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay Error: Layout elements exceeded __maxElementCount after adding the debug-view to the layout.")}
		} else {
			message = String{IsStaticallyAllocated: true, Length: int32(((len("Clay Error: Layout elements exceeded __maxElementCount") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("Clay Error: Layout elements exceeded __maxElementCount")}
		}
		__AddRenderCommand(RenderCommand{BoundingBox: BoundingBox{X: context.layoutDimensions.Width/2 - 59*4, Y: context.layoutDimensions.Height / 2, Width: 0, Height: 0}, RenderData: RenderData{Text: TextRenderData{StringContents: StringSlice{Length: message.Length, Chars: message.Chars, BaseChars: message.Chars}, TextColor: Color{R: 255, G: 0, B: 0, A: 255}, FontSize: 16}}, CommandType: RENDER_COMMAND_TYPE_TEXT})
	}
	if context.openLayoutElementStack.Length > 1 {
		context.errorHandler.ErrorHandlerFunction(ErrorData{ErrorType: ERROR_TYPE_UNBALANCED_OPEN_CLOSE, ErrorText: String{IsStaticallyAllocated: true, Length: int32(((len("There were still open layout elements when EndLayout was called. This results from an unequal number of calls to __OpenElement and __CloseElement.") + 1) / int(unsafe.Sizeof(byte(0)))) - int(unsafe.Sizeof(byte(0)))), Chars: libc.CString("There were still open layout elements when EndLayout was called. This results from an unequal number of calls to __OpenElement and __CloseElement.")}, UserData: context.errorHandler.UserData})
	}
	__CalculateFinalLayout()
	return context.renderCommands
}

func getElementId(idString String) ElementId {
	return __HashString(idString, 0)
}

func getElementIdWithIndex(idString String, index uint32) ElementId {
	return __HashStringWithOffset(idString, index, 0)
}

func Hovered() bool {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return false
	}
	var openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	if openLayoutElement.Id == 0 {
		__GenerateIdForAnonymousElement(openLayoutElement)
	}
	for i := int32(0); i < context.pointerOverIds.Length; i++ {
		if ElementIdArray_Get(&context.pointerOverIds, i).Id == openLayoutElement.Id {
			return true
		}
	}
	return false
}

func OnHover(onHoverFunction func(elementId ElementId, pointerInfo PointerData, userData int64), userData any) {
	var context *Context = GetCurrentContext()
	if context.booleanWarnings.MaxElementsExceeded {
		return
	}
	var openLayoutElement *LayoutElement = __GetOpenLayoutElement()
	if openLayoutElement.Id == 0 {
		__GenerateIdForAnonymousElement(openLayoutElement)
	}
	var hashMapItem *LayoutElementHashMapItem = __GetHashMapItem(openLayoutElement.Id)
	hashMapItem.OnHoverFunction = onHoverFunction
	hashMapItem.HoverFunctionUserData = userData
}

func PointerOver(elementId ElementId) bool {
	var context *Context = GetCurrentContext()
	for i := int32(0); i < context.pointerOverIds.Length; i++ {
		if ElementIdArray_Get(&context.pointerOverIds, i).Id == elementId.Id {
			return true
		}
	}
	return false
}

func GetScrollContainerData(id ElementId) ScrollContainerData {
	var context *Context = GetCurrentContext()
	for i := int32(0); i < context.scrollContainerDatas.Length; i++ {
		var scrollContainerData *__ScrollContainerDataInternal = __ScrollContainerDataInternalArray_Get(&context.scrollContainerDatas, i)
		if scrollContainerData.ElementId == id.Id {
			var clipElementConfig *ClipElementConfig = __FindElementConfigWithType(scrollContainerData.LayoutElement, __ELEMENT_CONFIG_TYPE_CLIP).ClipElementConfig
			if clipElementConfig == nil {
				return ScrollContainerData{}
			}
			return ScrollContainerData{ScrollPosition: &scrollContainerData.ScrollPosition, ScrollContainerDimensions: Dimensions{Width: scrollContainerData.BoundingBox.Width, Height: scrollContainerData.BoundingBox.Height}, ContentDimensions: scrollContainerData.ContentSize, Config: *clipElementConfig, Found: true}
		}
	}
	return ScrollContainerData{}
}

func GetElementData(id ElementId) ElementData {
	var item *LayoutElementHashMapItem = __GetHashMapItem(id.Id)
	if item == &LayoutElementHashMapItem_DEFAULT {
		return ElementData{}
	}
	return ElementData{BoundingBox: item.BoundingBox, Found: true}
}

func SetDebugModeEnabled(enabled bool) {
	var context *Context = GetCurrentContext()
	context.debugModeEnabled = enabled
}

func IsDebugModeEnabled() bool {
	var context *Context = GetCurrentContext()
	return context.debugModeEnabled
}

func SetCullingEnabled(enabled bool) {
	var context *Context = GetCurrentContext()
	context.disableCulling = !enabled
}

func SetExternalScrollHandlingEnabled(enabled bool) {
	var context *Context = GetCurrentContext()
	context.externalScrollHandlingEnabled = enabled
}

func GetMaxElementCount() int32 {
	var context *Context = GetCurrentContext()
	return context.maxElementCount
}

func SetMaxElementCount(maxElementCount int32) {
	var context *Context = GetCurrentContext()
	if context != nil {
		context.maxElementCount = maxElementCount
	} else {
		__defaultMaxElementCount = maxElementCount
		__defaultMaxMeasureTextWordCacheCount = maxElementCount * 2
	}
}

func GetMaxMeasureTextCacheWordCount() int32 {
	var context *Context = GetCurrentContext()
	return context.maxMeasureTextCacheWordCount
}

func SetMaxMeasureTextCacheWordCount(maxMeasureTextCacheWordCount int32) {
	var context *Context = GetCurrentContext()
	if context != nil {
		__currentContext.maxMeasureTextCacheWordCount = maxMeasureTextCacheWordCount
	} else {
		__defaultMaxMeasureTextWordCacheCount = maxMeasureTextCacheWordCount
	}
}

func ResetMeasureTextCache() {
	var context *Context = GetCurrentContext()
	context.measureTextHashMapInternal.Length = 0
	context.measureTextHashMapInternalFreeList.Length = 0
	context.measureTextHashMap.Length = 0
	context.measuredWords.Length = 0
	context.measuredWordsFreeList.Length = 0
	for i := int32(0); i < context.measureTextHashMap.Capacity; i++ {
		*(*int32)(unsafe.Add(unsafe.Pointer(context.measureTextHashMap.InternalArray), unsafe.Sizeof(int32(0))*uintptr(i))) = 0
	}
	context.measureTextHashMapInternal.Length = 1
}
